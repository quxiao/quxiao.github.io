
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Xavier's Blog</title>
  <meta name="author" content="Xavier">

  
  <meta name="description" content="Decorator模式，又称装饰模式。在实际编程中，如果希望能在原有基础上动态的添加新的功能或者扩展已有功能，那么Decorator模式提供了一种很好的解决方案。Decorator模式如下图所示： &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://quxiao.github.io/blog/page/6">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Xavier's Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Xavier's Blog</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:quxiao.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/04/08/decorator_pattern/">Decorator模式初探</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-04-08T19:03:06+08:00" pubdate data-updated="true">Apr 8<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/04/08/decorator_pattern/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/04/08/decorator_pattern/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Decorator模式，又称装饰模式。在实际编程中，如果希望能在原有基础上动态的添加新的功能或者扩展已有功能，那么Decorator模式提供了一种很好的解决方案。Decorator模式如下图所示：</p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/04/image5.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/04/image_thumb5.png" alt="image" /></a></p>

<p>具体的实现类ConcreteComponent和装饰类Decorator均实现了Component接口，装饰类含有一个Component类作为其成员。这样，当需要在ConcreteComponent基础上添加新的功能时，只需扩展Decorator形成具有某一特定功能的Decorator即可。由于不同的Decorator都是遵循Component接口，当需要扩展新功能时，在原有的Decorator上再套一层Decorator就可以啦。</p>

<p>来用一个简单的例子解释一下吧。比如现在有个手机类SimplePhone，实现了Phone接口：</p>

<pre><code>public interface Phone {
    String getDescription();
    int getCost();
}

package org.quxiao.phone;

public class SimplePhone implements Phone {

    @Override
    public String getDescription() {
        return "simple phone";
    }

    @Override
    public int getCost() {
        return 100;
    }

}
</code></pre>

<p>为了能动态增加功能，做一个抽象的Decorator：</p>

<pre><code>public abstract class AbstractPhoneDecorator implements Phone {
    protected Phone phone;

    public AbstractPhoneDecorator(Phone phone)
    {
        this.phone = phone;
    }
}
</code></pre>

<p>现在需要给手机添加GPS模块，扩展抽象的Decorator：</p>

<pre><code>public class GPSPhoneDecorator extends AbstractPhoneDecorator {

    public GPSPhoneDecorator(Phone phone) {
        super(phone);
    }

    @Override
    public String getDescription() {
        // TODO Auto-generated method stub
        return phone.getDescription() + " and GPS";
    }

    @Override
    public int getCost() {
        // TODO Auto-generated method stub
        return phone.getCost() + 100;
    }

}
</code></pre>

<p>同理，再添加蓝牙的模块：</p>

<pre><code>public class BlueToothPhoneDecorator extends AbstractPhoneDecorator {

    public BlueToothPhoneDecorator(Phone phone) {
        super(phone);
    }

    @Override
    public String getDescription() {
        return phone.getDescription() + " and blue tooth";
    }

    @Override
    public int getCost() {
        return phone.getCost() + 200;
    }

}
</code></pre>

<p>这样，我们就可以给SimplePhone类动态的添加模块了</p>

<pre><code>public class Main {

    public static void main(String[] args) {
        Phone simplePhone = new SimplePhone();
        Phone GPSPhone = new GPSPhoneDecorator(simplePhone);
        Phone myPhone = new GPSPhoneDecorator(new BlueToothPhoneDecorator(new SimplePhone()));

        System.out.println("simplePhone description : " + simplePhone.getDescription());
        System.out.println("simplePhone cost : " + simplePhone.getCost());
        System.out.println("GPSPhone description : " + GPSPhone.getDescription());
        System.out.println("GPSPhone cost : " + GPSPhone.getCost());
        System.out.println("myPhone description : " + myPhone.getDescription());
        System.out.println("myPhone cost : " + myPhone.getCost());
    }
}
</code></pre>

<blockquote><p>simplePhone description : simple phone
simplePhone cost : 100
GPSPhone description : simple phone and GPS
GPSPhone cost : 200
myPhone description : simple phone and blue tooth and GPS
myPhone cost : 400</p></blockquote>

<p>其实，Java I/O库中就是用了Decorator模式。</p>

<p>在基于Stream的输入中，所有数据都抽象成InputStream类，其子类FilterInputStream就相当于InputStream的装饰类。<a href="http://download.oracle.com/javase/6/docs/api/java/io/BufferedInputStream.html">BufferedInputStream</a>, <a href="http://download.oracle.com/javase/6/docs/api/java/util/zip/CheckedInputStream.html">CheckedInputStream</a>, <a href="http://download.oracle.com/javase/6/docs/api/javax/crypto/CipherInputStream.html">CipherInputStream</a>, <a href="http://download.oracle.com/javase/6/docs/api/java/io/DataInputStream.html">DataInputStream</a>, <a href="http://download.oracle.com/javase/6/docs/api/java/util/zip/DeflaterInputStream.html">DeflaterInputStream</a>, <a href="http://download.oracle.com/javase/6/docs/api/java/security/DigestInputStream.html">DigestInputStream</a>,<a href="http://download.oracle.com/javase/6/docs/api/java/util/zip/InflaterInputStream.html">InflaterInputStream</a>, <a href="http://download.oracle.com/javase/6/docs/api/java/io/LineNumberInputStream.html">LineNumberInputStream</a>, <a href="http://download.oracle.com/javase/6/docs/api/javax/swing/ProgressMonitorInputStream.html">ProgressMonitorInputStream</a>, <a href="http://download.oracle.com/javase/6/docs/api/java/io/PushbackInputStream.html">PushbackInputStream</a>都扩展自FilterInputStream，每个都对应于一个特定的功能。比如哦BufferedInputStream具有缓存功能，DataInputStream可将读出基本（primitive）类型的数据。因此，当我们使用Java I/O库进行输入输出时，总会生成一堆的类，就像这样：</p>

<pre><code>DataInputStream dis = new DataInputStream( new BufferedInputStream( new FileInputStream(FILE_LOC)));
</code></pre>

<p>之前一直不明白为什么Java的输入输出会这么麻烦，原来是因为用到了Decorator模式。现在明白了其中的原理，也觉得不那么复杂了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/04/05/cglib-dynamic-proxy-mode/">CGLib动态代理模式</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-04-05T17:30:52+08:00" pubdate data-updated="true">Apr 5<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/04/05/cglib-dynamic-proxy-mode/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/04/05/cglib-dynamic-proxy-mode/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>CGLib，即code generation library，原理是通过动态生成类以实现代理的功能。<a href="http://www.qxavier.me/2011/04/03/aop-and-dynamic-proxy-mode/">上一篇</a>文章中，我们提到了AOP（面向切片编程）以及AOP的一种实现方法——Java Dynamic Proxy。需要注意的是，Java动态代理是面向接口的，即被代理的类必须实现某个接口，代理类以该接口的形式出现，而使用CGLib，则没有这方面的限制，任意一个类都是可以的。</p>

<p>简单的说，使用CGLib代理某个类，需要在Enhancer对象中设置好基类（也就是被代理类），以及一系列回调函数Callback。Callback是一个接口，CGLib提供了6个它的子接口：</p>

<p><strong>Callback子接口</strong></p>

<p><strong>用途（有待确认）</strong></p>

<p><a href="http://cglib.sourceforge.net/apidocs/net/sf/cglib/proxy/Dispatcher.html">Dispatcher</a></p>

<p>分发给其他Callback</p>

<p><a href="http://cglib.sourceforge.net/apidocs/net/sf/cglib/proxy/FixedValue.html">FixedValue</a></p>

<p>仅仅返回被代理类方法的返回值，对于限定某一些特定方法很有用（因为返回值必须和被代理类方法的返回值类型相匹配）</p>

<p><a href="http://cglib.sourceforge.net/apidocs/net/sf/cglib/proxy/InvocationHandler.html">InvocationHandler</a></p>

<p>主要用于Proxy（替代Java动态代理），也可以用户Enhancer</p>

<p><a href="http://cglib.sourceforge.net/apidocs/net/sf/cglib/proxy/LazyLoader.html">LazyLoader</a></p>

<p>与Dispatcher类似，当代理类的第一个lazily-load方法调用时才会被调用</p>

<p><a href="http://cglib.sourceforge.net/apidocs/net/sf/cglib/proxy/MethodInterceptor.html">MethodInterceptor</a></p>

<p>普通用途的回调方法，在处理逻辑（advice）前后进行处理</p>

<p><a href="http://cglib.sourceforge.net/apidocs/net/sf/cglib/proxy/NoOp.html">NoOp</a></p>

<p>直接调用基类（被代理类）的方法调用</p>

<p>好，那我们来假设一个场景吧。</p>

<p>有这样一个类RealObject，它可以查询、保存资源，比如是这样：</p>

<pre><code>public class RealObject {
    public void queryA ()
    {
        System.out.println("queryA");
    }
    public void queryB ()
    {
        System.out.println("queryB");
    }
    public void saveA ()
    {
        System.out.println("saveA");
    }
    public void saveB ()
    {
        System.out.println("saveB");
    }
}
</code></pre>

<p>我们有这样的需求：保存资源时，需要加入事务功能。那么可以实现自己的MethodInterceptor，实现其中的intercept方法：</p>

<pre><code>public class MyMethodInterceptor implements MethodInterceptor {

    @Override
    public Object intercept(Object obj, Method method, Object[] args,
            MethodProxy proxy) throws Throwable {
        // TODO Auto-generated method stub
        System.out.println(obj.getClass());
        //模拟事务功能
        if ( method.getName().startsWith("save") )
        {
            System.out.println("begin transaction");
        }
        Object result = proxy.invokeSuper(obj, args);
        if ( method.getName().startsWith("save") )
        {
            System.out.println("end transaction");
        }
        System.out.println("************************\n");
        return result;
    }
}
</code></pre>

<p>再来写主入口：</p>

<pre><code>public class Main {

    /**
     * @param args
     */
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        Enhancer enhancer = new Enhancer();
        //将需要代理的类作为基类
        enhancer.setSuperclass(RealObject.class);
        //设置回调功能，这里使用的是拦截器，
        //当被代理类调用方法时，会执行拦截器的intercept方法
        enhancer.setCallback(new MyMethodInterceptor());
        RealObject realObj = (RealObject) enhancer.create();
        consume(realObj);
    }

    private static void consume(RealObject realObj)
    {
        realObj.queryA();
        realObj.queryB();
        realObj.saveA();
        realObj.saveB();
    }
}
</code></pre>

<p>运行一下，看看效果吧！</p>

<pre><code>class org.quxiao.RealObject$$EnhancerByCGLIB$$91eddf0b
queryA
************************

class org.quxiao.RealObject$$EnhancerByCGLIB$$91eddf0b
queryB
************************

class org.quxiao.RealObject$$EnhancerByCGLIB$$91eddf0b
begin transaction
saveA
end transaction
************************

class org.quxiao.RealObject$$EnhancerByCGLIB$$91eddf0b
begin transaction
saveB
end transaction
************************
</code></pre>

<p>我们可以看到，CGLib动态生成了一个叫RealObject$$EnhancerByCGLIB$$91eddf0b的类，这个类就是RealObject的代理类。以后有时间来反编译一下，研究研究CGLib动态生成类的原理。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/04/03/aop-and-dynamic-proxy-mode/">AOP以及动态代理模式</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-04-03T14:00:53+08:00" pubdate data-updated="true">Apr 3<span>rd</span>, 2011</time>
        
           | <a href="/blog/2011/04/03/aop-and-dynamic-proxy-mode/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/04/03/aop-and-dynamic-proxy-mode/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>AOP，即面向方面的编程（面向“切片”的编程应该更合适）。按我的理解，就是对业务逻辑中的某一阶段进行抽取，以达到逻辑模块之前低耦合的编程方法。举个例子，一个系统有许多资源，只有当用户登录系统之后才能访问。那么，验证用户登录就可以抽象成一个“切片”，插在了用户和系统资源之间，编写各个业务模块的人就不用去关心验证用户登录的工作了，验证登录的工作会进行统一配置。</p>

<p>Spring采用的是动态AOP，即通过动态代理模式，在目标对象调用方法前后进行相应处理。</p>

<p>Spring中的动态AOP是基于以下两种方式实现的：</p>

<ul>
<li><p>Java Dynamic Proxy</p></li>
<li><p>CGLIB（code generation library）</p></li>
</ul>


<p>Java Dynamic Proxy是面向接口的，而CGLIB是面向类的。两者的关系可以参考这张图：
<a href="http://www.qxavier.me/wp-content/uploads/2011/04/image4.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/04/image_thumb4.png" alt="image" /></a></p>

<p>UserDAOImp是我们需要代理的类，Java动态代理类需要实现了UserDAOImp所实现的接口，（这也要求UserDAOImp必须实现某个接口），而CGLIB则是扩展了UserDAOImp类。</p>

<p>我们先来利用Java Dynamic Proxy实现代理功能。比如目前有一个类RealObject，它实现了接口Interface</p>

<p>Interface</p>

<pre><code>public interface Interface {
    void funcA ();
    void funcB (String str);
    void saveXXX ();
}
</code></pre>

<p>RealObject</p>

<pre><code>public class RealObject implements Interface {

    @Override
    public void funcA() {
        // TODO Auto-generated method stub
        System.out.println("funcA() in RealObject");
    }

    @Override
    public void funcB(String str) {
        // TODO Auto-generated method stub
        System.out.println("funcB() in RealObject : " + str);
    }

    @Override
    public void saveXXX() {
        // TODO Auto-generated method stub
        System.out.println("saveXXX() in RealObject");
    }
}
</code></pre>

<p>假设我们需要代理RealObject，在调用方法前后进行相应处理（输出信息），那么我们就需要一个实现了InvacationHandler接口的类，比如说是ProxyInvacationHandler</p>

<p>ProxyInvacationHandler</p>

<pre><code>public class ProxyInvocationHandler implements InvocationHandler {

    private Object proxied;

    public ProxyInvocationHandler (Object proxied)
    {
        this.proxied = proxied;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
        // TODO Auto-generated method stub
        Object result = null;

        System.out.print("n*******************n");
        System.out.println(proxy.getClass());   //invoke中第一个参数proxy意义何在？
        //模拟增加事务处理功能
        if ( method.getName().startsWith("save") )
        {
            System.out.println("transaction begins");
        }
        System.out.println("before " + method);
        //被代理的类调用实际的方法
        result = method.invoke(proxied, args);

        System.out.println("after " + method);
        if ( method.getName().startsWith("save") )
        {
            System.out.println("transaction ends");
        }
        System.out.print("*******************n");
        return result;
    }

}
</code></pre>

<p>其中的invoke方法就表示当被代理的类调用方法的前后，我们可以做的操作。甚至可以根据方法的不同，选择不同的操作。</p>

<p>最后，再通过Proxy的newProxyInstance静态方法动态生成代理类，因为代理类也是实现Interface接口的，所以操作代理类就像操作被代理类一样。</p>

<p>以下是运行结果：</p>

<pre><code>funcA() in RealObject
funcB() in RealObject : 123
saveXXX() in RealObject

*******************
class $Proxy0
before public abstract void org.quxiao.Interface.funcA()
funcA() in RealObject
after public abstract void org.quxiao.Interface.funcA()
*******************

*******************
class $Proxy0
before public abstract void org.quxiao.Interface.funcB(java.lang.String)
funcB() in RealObject : 123
after public abstract void org.quxiao.Interface.funcB(java.lang.String)
*******************

*******************
class $Proxy0
transaction begins
before public abstract void org.quxiao.Interface.saveXXX()
saveXXX() in RealObject
after public abstract void org.quxiao.Interface.saveXXX()
transaction ends
*******************
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/04/02/webx3-sample-project-login-webx3-tutorial-study-notes-a/">Webx3样例工程login-webx3-tutorial学习笔记（一）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-04-02T17:48:09+08:00" pubdate data-updated="true">Apr 2<span>nd</span>, 2011</time>
        
           | <a href="/blog/2011/04/02/webx3-sample-project-login-webx3-tutorial-study-notes-a/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/04/02/webx3-sample-project-login-webx3-tutorial-study-notes-a/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在eclipse中部署好工程，然后再通过jetty启动server，工程的功能相当简单，就是将表单中的字符串提交后显示。通过运行和调试，初步了解了webx的运行流程。</p>

<p>首先看一下WEB-INF中的配置文件</p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/04/image.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/04/image_thumb.png" alt="image" /></a></p>

<p>web.xml是J2EE工程必须的配置文件，webx.xml以及common中的xml都是webx框架公用的配置文件，而app1文件夹以及webx-app1.xml就是名为&#8221;app1&#8221;的模块配置文件。</p>

<p>配置文件的详细设置我们稍后再谈，我们直接通过运行实例来讲解流程吧。</p>

<p>打开首页，内容是通过Velocity生成的：</p>

<p>index.vm</p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/04/image1.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/04/image_thumb1.png" alt="image" /></a></p>

<p>提交表单之后，即会运行com.alibaba.webx.tutorial.app1.module.action.SimpleAction中的doGreeting方法。那为什么会跳转到这边呢？其实都是写在配置文件中的。</p>

<p>来看看webx-app1.xml</p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/04/image2.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/04/image_thumb2.png" alt="image" /></a></p>

<p>它指定了app1模块所在的包。再看index.vm，“simple_action”表示查找SimpleAction类，“event_submit_do_greeting”表示执行SimlieAction类中的doGreeting方法。（name是否一定设为“action”我还不确定）</p>

<p>试着修改一下，我们将index.vm中的simple_action修改为my_action、event_submit_do_greeting改为event_submit_do_my_greeting，再在com.alibaba.webx.tutorial.app1.module.action包中加入MyAction类，并添加doMyGreeting方法。重启服务器，就可看到效果。输入111，结果就会变成my111。</p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/04/image3.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/04/image_thumb3.png" alt="image" /></a></p>

<p>好，基本知道了解流程了，但理解得还是很凌乱，尤其是配置文件加载以及动态定位到某个类的原理。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/03/31/java-memory-mapped-file-stream-and-the-i-o-performance-comparison/">Java中Stream和Memory-mapped File的I/O性能对比</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-03-31T20:15:33+08:00" pubdate data-updated="true">Mar 31<span>st</span>, 2011</time>
        
           | <a href="/blog/2011/03/31/java-memory-mapped-file-stream-and-the-i-o-performance-comparison/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/03/31/java-memory-mapped-file-stream-and-the-i-o-performance-comparison/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>建立和使用I/O系统，不管对于哪一种语言都是困难的（在Java中使用I/O库尤其困难）。在Java中，会有多种方式对于文件或者设备进行I/O操作。方法不同，性能很有差异。今天我们来对比一下通过Stream以及Memory-mapped File这两种方式的I/O性能对比。</p>

<p><strong>Stream</strong></p>

<p>“流”是I/O系统中通常使用的抽象概念，表示可以发出或者接受数据的点（source / sink）。“流”的概念也屏蔽掉了不同设备间的细节差异。   <br/>
Input stream通常可以为：</p>

<ul>
<li><p>字节数组</p></li>
<li><p>String对象</p></li>
<li><p>文件</p></li>
<li><p>管道（pipe）</p></li>
<li><p>其他流（将多个流组成一个流）</p></li>
<li><p>网络设备等</p></li>
</ul>


<p>Output stream通常可以为：</p>

<ul>
<li><p>字节数组</p></li>
<li><p>文件</p></li>
<li><p>管道</p></li>
</ul>


<p><strong>Memory-mapped File</strong></p>

<p>对于那些很大的文件，将整个文件全部读进内存，将会极大地影响性能。通过Memory-mapped File可以只将文件的一部分读入内存，其他部分被换出（swap out），这样就能效率很高的读写大文件。</p>

<p>在Java的nio包中，用到了两种更接近于操作系统具体实现的数据结构：channel和buffer，memory-mapped file中就用到了channel。这种I/O方式，用户不需要跟数据源打交道，而只需把数据放到channel和buffer中，然后再调相应函数就可以了，通过这种“底层”的操作，已得到最大的I/O性能。（这种方式其实就跟C中的read和write一样了）</p>

<p>通过测试程序，我们可以看到两种方式性能的对比：</p>

<p>(注：表格中的文件大小N表示文件中含有N个char，而读写时间为ms)</p>

<p>读写方式  文件大小</p>

<p>10</p>

<p>100</p>

<p>2<sup>10</sup></p>

<p>2<sup>20</sup></p>

<p>2<sup>21</sup></p>

<p>2<sup>22</sup></p>

<p>Stream Write</p>

<p>1.874</p>

<p>1.974</p>

<p>1.828</p>

<p>161.258</p>

<p>368.252</p>

<p>656.428</p>

<p>Memory-mapped File Write</p>

<p>2.5</p>

<p>6.648</p>

<p>1.265</p>

<p>11.774</p>

<p>20.23</p>

<p>46.262</p>

<p>Stream Read</p>

<p>0.122</p>

<p>0.174</p>

<p>0.58</p>

<p>158.352</p>

<p>313.37</p>

<p>627.531</p>

<p>Memory-mapped File Read</p>

<p>0.428</p>

<p>0.463</p>

<p>0.382</p>

<p>10.797</p>

<p>19.381</p>

<p>39.749</p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/03/image.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/03/image_thumb.png" alt="image" /></a></p>

<p>可以看到，文件很小时，Memory-mapped方式是没有优势的，而当读写大文件时，优势就十分明显了。</p>

<p>关键代码如下：</p>

<pre><code>public class IOPerComp {

    /**
     * @param args
     */
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        int[] intSizes = {10, 100, 1&lt;&lt;10, 1&lt;&lt;20, 1&lt;&lt;21, 1&lt;&lt;22};
        for (int i = 0; i &lt; intSizes.length; i ++)
        {
            INT_SIZE = intSizes[i];
            System.out.println("file size : " + INT_SIZE);
            for (Tester tester : tests)
            {
                tester.runTest();
            }
            System.gc();
            System.out.println("**********************");
        }
    }

    private static final String FILE_LOC = "D:/tmpFile.txt";
    private static int INT_SIZE = 1024 * 1024;
    private abstract static class Tester {
        private String name;
        public Tester () {}
        public Tester (String name)
        {
            this.name = name;
        }
        public void runTest ()
        {
            System.out.println("name : " + name);
            long start = System.nanoTime();
            try
            {
                test();
            }
            catch (IOException ioe)
            {
                ioe.printStackTrace();
            }
            start = System.nanoTime() - start;
            System.out.format("time : %.3fn", start/1.0e6);
        }
        public abstract void test() throws IOException;
    }

    private static Tester[] tests= {
        new Tester("Stream Write")
        {
            public void test() throws IOException
            {
                File f = new File (FILE_LOC);
                if ( f.exists() )
                    f.delete();
                DataOutputStream dos = new DataOutputStream(
                        new BufferedOutputStream(
                                new FileOutputStream(FILE_LOC)));
                for (int i = 0; i &lt; INT_SIZE; i ++)
                    dos.writeInt(i);
                dos.close();
            }
        },
        new Tester("Mapped Write")
        {
            public void test() throws IOException
            {
                FileChannel fc = new RandomAccessFile(FILE_LOC, "rw").getChannel();
                IntBuffer ib = fc.map(FileChannel.MapMode.READ_WRITE, 0, fc.size()).asIntBuffer();
                for (int i = 0; i &lt; INT_SIZE; i ++)
                    ib.put(i);
                fc.close();
            }
        },
        new Tester("Stream Read")
        {
            public void test() throws IOException
            {
                DataInputStream dis = new DataInputStream(
                        new BufferedInputStream(
                                new FileInputStream(FILE_LOC)));
                for (int i = 0; i &lt; INT_SIZE; i ++)
                {
                    dis.readInt();
                }
                dis.close();
            }
        },
        new Tester("Mapped Read")
        {
            public void test() throws IOException
            {
                FileChannel fc = new FileInputStream(FILE_LOC).getChannel();
                IntBuffer ib = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size()).asIntBuffer();
                while ( ib.hasRemaining() )
                {
                    ib.get();
                }
                fc.close();
            }
        }
    };
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/03/15/linux-api-practice-the-signal-sent-waiting-and-arrival/">Linux API实践：信号的发出、等待以及到达</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-03-15T21:07:15+08:00" pubdate data-updated="true">Mar 15<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/03/15/linux-api-practice-the-signal-sent-waiting-and-arrival/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/03/15/linux-api-practice-the-signal-sent-waiting-and-arrival/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>信号是Linux中的重要概念，其表示着某种事件的发生（或者结束）。</p>

<p>信号可以用三种状态：产生（generated）、等待（pending）以及到达（delivered）。这三种状态是按时间顺序出现的，我们尤其要注意pending状态，因为并不是信号一旦产生，就会立即到达目标进程，信号在产生和到达中间的状态就为等待。</p>

<p>进程可以对到达的信号进行阻止（block），如果被阻止的信号到达进程，该信号的状态就会一直保持等待，直到</p>

<ul>
<li>进程解除对该信号的阻止，或者</li>
<li>进程忽略（ignore）到该信号</li>
</ul>


<p>如果被阻止的信号在解除阻止之前产生了多次，多个相同种信号会进行队列处理（queued）吗？答案是大部分的UNIX系统都不会将多个同种信号进行队列处理，而是只算一次。（貌似在POSIX.1上增加实时扩展功能才能支持多个同种pending信号的队列化处理。）话不多说，实践一下吧！</p>

<p>程序1简单的向自身发出了多次SIGUSR1信号，并且在信号处理函数中记录了发生的次数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;signal.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="n">sigusr1_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span> <span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">sigset_t</span> <span class="n">oldmask</span><span class="p">,</span> <span class="n">newmask</span><span class="p">,</span> <span class="n">pendmask</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span> <span class="n">signal</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">sigusr1_handler</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span> <span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;signal error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">raise</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">);</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;send SIGUSR1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sleep started</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sleep finished</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="n">sigusr1_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;receive user1 signal %d times</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n</span> <span class="o">++</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span> <span class="n">signal</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">sigusr1_handler</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span> <span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;can&#39;t reset SIGUSR1&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>程序的结果应该很明显：</p>

<pre><code>receive user1 signal 1 times
send SIGUSR1
receive user1 signal 2 times
send SIGUSR1
receive user1 signal 3 times
send SIGUSR1
receive user1 signal 4 times
send SIGUSR1
receive user1 signal 5 times
send SIGUSR1
sleep started
sleep finished
</code></pre>

<p>程序2在程序1的基础上，增加了发出信号之前阻止了该信号，以及之后再解除阻止的操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;signal.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="n">sigusr1_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span> <span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">sigset_t</span> <span class="n">oldmask</span><span class="p">,</span> <span class="n">newmask</span><span class="p">,</span> <span class="n">pendmask</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//加入SIGUSR1信号处理函数</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span> <span class="n">signal</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">sigusr1_handler</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span> <span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;signal error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//阻止SIGUSR1信号</span>
</span><span class='line'>  <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">);</span>
</span><span class='line'>  <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span> <span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sigprocmask block error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;SIGUSR1 is blocked</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//发出信号</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">raise</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">);</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;send SIGUSR1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sleep started</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sleep finished</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span> <span class="n">sigpending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pendmask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sigpending error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span> <span class="n">sigismember</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pendmask</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">)</span> <span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;SIGUSR1 was pending</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//恢复之前的信号掩码</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span> <span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sigprocmask setmask error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;restore old signal mask</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="n">sigusr1_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;receive user1 signal %d times</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n</span> <span class="o">++</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span> <span class="n">signal</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">sigusr1_handler</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span> <span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;can&#39;t reset SIGUSR1&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>再来看运行的结果：</p>

<pre><code>SIGUSR1 is blocked
send SIGUSR1
send SIGUSR1
send SIGUSR1
send SIGUSR1
send SIGUSR1
sleep started
sleep finished
SIGUSR1 was pending
receive user1 signal 1 times
restore old signal mask
</code></pre>

<p>虽然发出了多次信号，但由于之前的阻止设置使其发出后处于等待状态，多个同种信号pending，信号处理函数果然只接受到了1次，跟书中讲的是一致的。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/03/15/usaco-section-3-3-a-game/">USACO Section 3.3 a Game</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-03-15T11:03:36+08:00" pubdate data-updated="true">Mar 15<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/03/15/usaco-section-3-3-a-game/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/03/15/usaco-section-3-3-a-game/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>题目大意：有一串长度为N（2&lt;=N&lt;=100）的正整数，两个人按顺序选取最左边或最右边的一个数，将这个数字从数列中去掉，求在双方都进行最优化的选择时，双方选择数字的和分别为多少？</p>

<p>一开始题目的状态为（0，n-1），我们来考虑某个中间状态（i，j）。当前玩家有两种选择：i或者j。选择i，状态就变成（i+1，j）；选择j，状态就变为（i，j-1）；当i==j时，玩家没得选，只能选择i，然后游戏结束。</p>

<p>我们可以用f[i][j]表示在(i, j)情况下，当前玩家的最优解，即从(i, j)到游戏结束所选择的最大数字和。因为双方都是进行最优化选择，所以根据当前玩家选择i，则另一玩家之后的最优解为f[i+1][j]，那么这个情况下当前玩家拿到的数字和是多少呢？应该是sum[i][j] – f[i+1][j]。（sum[i][j]表示i到j的和）。同理，当前玩家选择j时，情况也是类似的。最后我们得到如下递推式：</p>

<pre><code>f[i][j] = max { sum[i][j] – f[i+1][j], sum[i][j] – f[i][j-1] } ( i &lt; j )

f[i][j] = v[i] ( i == j )
</code></pre>

<p>实现时，用递归加记忆化就可以解决了，算法复杂度为O(N<sup>2</sup>)。</p>

<p>关键代码如下：</p>

<pre><code>int CalF(int i, int j)
{
     if ( f[i][j] != -1 )
          return f[i][j];
     if ( i == j )
          return f[i][j] = v[i];
     return ( f[i][j] = sum[i][j] - min(CalF(i+1, j), CalF(i, j-1)) );
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/03/09/usaco-section-3-3-home-on-the-range/">USACO Section 3.3 Home on the Range</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-03-09T13:55:07+08:00" pubdate data-updated="true">Mar 9<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/03/09/usaco-section-3-3-home-on-the-range/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/03/09/usaco-section-3-3-home-on-the-range/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>题目大意：给定包含0和1的边长为N(2&lt;=N&lt;=250)的正方形，统计其中边长>=2并且全部由1组成的子正方形，子正方形可相互覆盖。</p>

<p>我的理解是，建立三个数组rightEx[][], downEx[][]和squareSize[][]，分别表示每一点最右和最下能扩展的距离以及可向右下扩展的（目前）最大正方形的边长，然后枚举组成的正方形边长K（2～N），再枚举每一个点（i, j），若满足以下三个条件：</p>

<ul>
<li><p>rightEx[i][j] >= k</p></li>
<li><p>downEx[i][j] >= k</p></li>
<li><p>squareSize[i+1][j+1] >= k – 1</p></li>
</ul>


<p>则squareSzie[i][j] = k，并且更新答案。</p>

<p>算法复杂度为O(N<sup>3</sup>)，还是可以接受的。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/03/05/linux-security-settings-under-the-process/">Linux下进程的安全性设置</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-03-05T10:00:37+08:00" pubdate data-updated="true">Mar 5<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/03/05/linux-security-settings-under-the-process/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/03/05/linux-security-settings-under-the-process/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>上一次我们讲过，如何用setrlimit限制进程的资源，并以时间和内存为例。这次我们来试试看更多的资源限制，以防止恶意代码的攻击，增加系统的安全性。</p>

<h2><strong>超时</strong></h2>

<p>超时上次不是讲过了吗？嗯，上次讲的是“忙”的超时，而这次是“sleep”的超时。通过实验发现，如果程序一直咋sleep，父进程是无法检测到子进程超时的，我想这应该是因为sleep的时间本身不算在进程的CPU时间内。那啥办呢？好办，加定时器（alarm）。例如：</p>

<pre><code>signal(SIGALRM, my_alarm_handler);
alarm(timeLimit * 2);
</code></pre>

<p>这样，当进程流逝的时间超过alarm的限制时，父进程也会受到相应的信号。</p>

<p>例如对于这样的代码：</p>

<pre><code>#include &lt;unistd.h&gt;

int main ()
{
    sleep(15);

    return 0;
}
</code></pre>

<p>运行结果如下：</p>

<blockquote><p>quxiao@quxiao-laptop:~/judge$ ./linux_judge_svn/linux/judge.o /home/quxiao/judge/a_and_b.in /home/quxiao/judge/out.txt 1 64 /home/quxiao/judge/just_sleep.o
input file: /home/quxiao/judge/a_and_b.in
output file: /home/quxiao/judge/out.txt
time limit: 1
memory limit: 67108864
cmd: /home/quxiao/judge/just_sleep.o
================parent process=====================
child exit status: 14
exit abnormally.
exit by signal: 14 | 14
parent process is finished.
child process time: 0 ms
maximum resident set size:    292</p></blockquote>

<h2>生成/打开文件</h2>

<p>有时我们并不希望子进程有文件操作（当然，除了输入输出设备这些特殊文件），可以通过修改RLIMIT_NOFILE的值来达到此效果。</p>

<p>如果程序会生成一些文件，代码如下：</p>

<pre><code>for (i = 0; i &lt; 10; i ++)
{
    char template[] = "template-XXXXXX";
    fd = mkstemp(template);
    if ( fd == -1 )
    {
        printf("can't create file!\n");
    }
}
</code></pre>

<p>那么，修改过限制之后的代码运行结果就是：</p>

<blockquote><p>quxiao@quxiao-laptop:~/judge$ ./linux_judge_svn/linux/judge.o /home/quxiao/judge/a_and_b.in /home/quxiao/judge/out.txt 1 64 /home/quxiao/judge/too_many_file.o
input file: /home/quxiao/judge/a_and_b.in
output file: /home/quxiao/judge/out.txt
time limit: 1
memory limit: 67108864
cmd: /home/quxiao/judge/too_many_file.o
================parent process=====================
child exit status: 0
exit normally.
parent process is finished.
child process time: 0 ms</p>

<h1>maximum resident set size:    364</h1></blockquote>

<p>quxiao@quxiao-laptop:~/judge$ cat out.txt
can&rsquo;t create file!
can&rsquo;t create file!
can&rsquo;t create file!
can&rsquo;t create file!
can&rsquo;t create file!
can&rsquo;t create file!
can&rsquo;t create file!
can&rsquo;t create file!
can&rsquo;t create file!</p>

<p>不过，从例子中可以看出，表面上父进程并没有检测到子进程的任何异常，但我们可以从输出文件中看到子进程的生成文件是受到限制的。另外，还有一点值得考虑，那就是子进程还是生成了一个文件的，RLIMIT_NOFILE到底应该设置成多少，还要再研究研究。</p>

<h2>生成子进程</h2>

<p>同样，让进程可以任意地生成子进程也是很危险的。RLIMIT_NPROC可以限制生成子进程的数目。对于如下代码：</p>

<pre><code>    for (i = 0; i &lt; 3; i ++)
    {
        pid_t pid;
        if ( (pid=fork()) == -1 )
        {
            printf("error!\n");
        }
        else if ( pid == 0 )
        {
            printf("this is child process\n");
        }
        else
        {
            printf("this is parent process\n");
        }
    }
</code></pre>

<p>运行结果如下：</p>

<blockquote><p>quxiao@quxiao-laptop:~/judge$ ./linux_judge_svn/linux/judge.o /home/quxiao/judge/a_and_b.in /home/quxiao/judge/out.txt 1 64 /home/quxiao/judge/too_many_child.o
input file: /home/quxiao/judge/a_and_b.in
output file: /home/quxiao/judge/out.txt
time limit: 1
memory limit: 67108864
cmd: /home/quxiao/judge/too_many_child.o
================parent process=====================
child exit status: 0
exit normally.
parent process is finished.
child process time: 0 ms</p>

<h1>maximum resident set size:    340</h1></blockquote>

<p>quxiao@quxiao-laptop:~/judge$ cat out.txt
error!
error!
error!</p>

<h2>runtime error</h2>

<p>当程序出现一些运行时错误的时候，父进程也可以通过信号检测到。这里其实跟资源限制没太大关系，但检测这方面的信息也是很重要的。举2个例子，1个是除0，1个是数组越界。</p>

<p>除0程序：</p>

<pre><code>int main ()
{
    int a, b;
    a = 1;
    b = 0;
    a = a / b;

    return 0;
}
</code></pre>

<blockquote><p>quxiao@quxiao-laptop:~/judge$ ./linux_judge_svn/linux/judge.o /home/quxiao/judge/a_and_b.in /home/quxiao/judge/out.txt 1 64 /home/quxiao/judge/divide0.o
input file: /home/quxiao/judge/a_and_b.in
output file: /home/quxiao/judge/out.txt
time limit: 1
memory limit: 67108864
cmd: /home/quxiao/judge/divide0.o
================parent process=====================
child exit status: 8
exit abnormally.
exit by signal: 8 | 8
parent process is finished.
child process time: 0 ms</p>

<h1>maximum resident set size:    292</h1></blockquote>

<p>数组越界程序：</p>

<pre><code>const int MAX = 100;

int main ()
{
    int array[MAX];
    int i;
    i = 0;
    while ( ++i )   /* so dangerous! */
    {
        array[i] = 0;
    }

    return 0;
}
</code></pre>

<blockquote><p>quxiao@quxiao-laptop:~/judge$ ./linux_judge_svn/linux/judge.o /home/quxiao/judge/a_and_b.in /home/quxiao/judge/out.txt 1 64 /home/quxiao/judge/re.o
input file: /home/quxiao/judge/a_and_b.in
output file: /home/quxiao/judge/out.txt
time limit: 1
memory limit: 67108864
cmd: /home/quxiao/judge/re.o
================parent process=====================
child exit status: 11
exit abnormally.
exit by signal: 11 | 11
parent process is finished.
child process time: 0 ms</p>

<h1>maximum resident set size:    288</h1></blockquote>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/03/04/usaco-section-3-3-shopping-offers/">USACO Section 3.3 Shopping Offers</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-03-04T15:59:14+08:00" pubdate data-updated="true">Mar 4<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/03/04/usaco-section-3-3-shopping-offers/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/03/04/usaco-section-3-3-shopping-offers/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>题目大意：</p>

<p>买N（0&lt;=N&lt;=5）类商品，每种买K（0&lt;=K&lt;=5）件，再给出S（0&lt;=S&lt;=99）个优惠价格列表，每种优惠给定一种商品及其数量的组合。</p>

<p>优惠列表如下：</p>

<pre><code>1 7 3 5
2 7 1 8 2 10
</code></pre>

<p>表示第1种优惠包含1类商品：7号商品买3件，优惠价为5；第2种优惠包含2类商品：7号商品买1件，8号商品买2件，优惠价为10。</p>

<p>求买这N类商品，每种K件，购买的最低价格是多少？</p>

<p>思路：</p>

<p>题目中要求买的商品的种类和数量都很少（&lt;=5），这很好，但S的数量级有点高，尽量避免枚举S很重要。商品最多5种，每种商品0～5个，那么商品类型和数目的组合状态就是6<sup>5</sup>种。每种组合的最优解（即最低价格）是唯一的，而组合的种类又不多，则很容易想到把子问题的解保存起来，避免重复计算。</p>

<p>对于当前的商品类型价格组合，如果之前已计算出来，则直接返回。否则，枚举每一种优惠，如果可以使用该种优惠，计算优惠价格加上剩下的组合，返回所有可以使用优惠的价格以及不使用优惠的价格中的最小值，作为当前情况的最优解。这样，问题就可以解决了，提交之后发现效率还可以。</p>

<p>关键代码如下：</p>

<pre><code>int getMinCost (int num[PRODUCT_NUM])
{
    int curState;
    curState = getState(num);
    if ( minCost[curState] != -1 )
        return minCost[curState];

    int i, j, minPrice = 0, curPrice, tmpNum[PRODUCT_NUM];
    bool check;
    for (i = 0; i &lt; proNum; i ++)
        minPrice += num[i] * price[i];
    for (i = 0; i &lt; offerNum; i ++)
    {
        curPrice = 0;
        check = true;
        for (j = 0; j &lt; proNum; j ++)
        {
            if ( num[j] - offerProIdxNum[i][j] &lt; 0 )
            {
                check = false;
                break;
            }
            tmpNum[j] = num[j] - offerProIdxNum[i][j];
        }
        if ( check )
        {
            curPrice = offerPrice[i] + getMinCost(tmpNum);
            if ( curPrice &lt; minPrice )
                minPrice = curPrice;
        }
    }
    return (minCost[curState] = minPrice);
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/7/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/5/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/04/05/functor/">Functor (Function Object)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/03/24/branch-in-my-eye/">公司设立分部弊端之我见</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/03/18/log-practice/">日志规范实践</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/02/24/a-try-to-play-with-travis-ci/">小试Travis-Ci</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/01/31/typelist-and-abstract-fatory/">Typelist && Abstract Fatory</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/quxiao">@quxiao</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'quxiao',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Xavier -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'qxavier';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
