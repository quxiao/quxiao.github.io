
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Xavier's Blog</title>
  <meta name="author" content="Xavier">

  
  <meta name="description" content="考虑到最近写毕业论文以及以后自己博客中的实验分析，绘制一些图表就变得在所难免，再加上最近对Python比较感兴趣，于是就找了写利用Python绘制图表的工具库。说实话，一找一大堆，挑了几个自己感觉不错的，作为候选。 matplotlib matplotlib可谓是matlab的Python版本， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://quxiao.github.io/blog/page/4">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Xavier's Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Xavier's Blog</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:quxiao.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/12/04/some_python_plotting_tools/">一些Python图表工具</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-04T17:10:39+08:00" pubdate data-updated="true">Dec 4<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/12/04/some_python_plotting_tools/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/12/04/some_python_plotting_tools/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>考虑到最近写毕业论文以及以后自己博客中的实验分析，绘制一些图表就变得在所难免，再加上最近对Python比较感兴趣，于是就找了写利用Python绘制图表的工具库。说实话，一找一大堆，挑了几个自己感觉不错的，作为候选。</p>

<h1><a href="http://matplotlib.sourceforge.net/">matplotlib</a></h1>

<p>matplotlib可谓是matlab的Python版本，可以绘制高质量的2D图表，例如柱状图，饼状图，散点图，以及很多我不知道科学图表。除了能以python script的形式编程，还能通过ipython shell来进行交互。另外，matplotlib不但能进行绘图，还能进行复杂的科学计算（通过 <a href="http://scipy.org/Numpy_Example_List_With_Doc">numpy</a>和<a href="http://matplotlib.sourceforge.net/api/mlab_api.html">matplotlib.mlab</a>）。如果之前熟悉matlab的话，应该能很快上手。    <br/>
matplotlib很好很强大，图表又好看，就算对于一个搞科研的人来说，也是足够的。不过相应的代价就是学习曲线较陡，尤其是对于之前没有接触过matlab和python的人来说。</p>

<h1><a href="https://bitbucket.org/lgs/pycha/wiki/Home">Pycha</a> (PYthon CHArts)</h1>

<p>Pycha是一个基于<a href="http://www.cairographics.org/">Cairo</a>图形库的、轻量级、易于使用的python包。Pycha在大多数默认情况下能有很漂亮的外观，当然你也可以定制各种细节。它并不像matplotlib那样可以画出几乎所有的图形，只是提供了一些常用的图表类型。</p>

<h1><a href="http://home.gna.org/pychart/">Pychart</a></h1>

<p>也是一个轻量级的python图形库，支持线状图、柱状图、饼状图、范围图，以及Encapsulated Postscript, PDF, PNG, SVG 等多种格式。图表外观朴素不花哨，已经够用了。   <br/>
有意思的是，官网上，作者还说自己写的这个图形库已经用在了自己发表的几篇论文里面了，还列举了一些与它类似的图形库并讲了他们的优缺点。再一查作者信息，果然是牛人，在HP实验室待过 ，05年去了google。</p>

<p>另外，还有像<a href="http://linil.wordpress.com/2008/09/16/cairoplot-11/">CairoPlot</a>、<a href="http://www.advsofteng.com/product.html">ChartDirector for Python</a>等也是不错的选择。下面是这些图形库的柱状图例子，可以有个直观的感觉。总的来说，如果时间充裕或者今后后大量用到科学图表的话，matplotlib就是最好的选择了。如果就偶尔画一些简单的图形的话，上面介绍的都能基本满足需求，实在不行干脆直接用VISIO！</p>

<p><strong>matplotlib</strong></p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/12/matplotlib.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/12/matplotlib.png" alt="" /></a></p>

<p>//////////////////////////////////////////////////////////////</p>

<p><strong>Pycha</strong></p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/12/pycha.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/12/pycha.png" alt="" />      <br/>
</a></p>

<p>//////////////////////////////////////////////////////////////</p>

<p><strong>Pychart</strong></p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/12/pychart1.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/12/pychart1-1024x350.png" alt="" /></a></p>

<p>//////////////////////////////////////////////////////////////</p>

<p><strong>CairoPlot</strong></p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/12/cairoplot.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/12/cairoplot.png" alt="" /></a></p>

<p>//////////////////////////////////////////////////////////////</p>

<p><strong>ChartDirector for Python</strong></p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/12/ChartDirector.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/12/ChartDirector.png" alt="" /></a></p>

<p>&mdash;EOF&mdash;</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/11/14/some_concepts_in_hadoop/">Hadoop中的一些概念</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-11-14T15:09:09+08:00" pubdate data-updated="true">Nov 14<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/11/14/some_concepts_in_hadoop/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/11/14/some_concepts_in_hadoop/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Hadoop，在不同的上下文的环境下，会表示不同范围的概念。有人可能把Hadoop单单理解为一个分布式文件系统，我感觉欠妥，因为也有很多其他的分布式文件系统。Hadoop之所以称为Hadoop，其核心在于它的MapReduce框架。所以，Hadoop的最精简的理解应该是HDFS （Hadoop Distributed File System）+ MapReduce。除了核心，也可以算上它的许多子项目，例如Hbase、Pig、Hive等等，可以通过下图来了解下Hadoop的Big Picture:</p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/11/hadoop_ecosys.jpg"><img src="http://www.qxavier.me/wp-content/uploads/2011/11/hadoop_ecosys_thumb.jpg" alt="hadoop_ecosys" /></a></p>

<p>既然HDFS以及MapReduce是Hadoop的核心，对于它们的一些概念就要有所掌握。好，下面来讲解一下。</p>

<h3>HDFS中的重要概念：</h3>

<p><strong>NameNode
</strong>它是整个HDFS的核心，里面包含了整个文件系统中的所有文件的路径，并且监控存有文件的服务器，NameNode本身并不存储文件。NameNode就相当于一个接口，当用户想要对HDFS中的文件进行读/写/添加/删除时，首先要询问NameNode，然后NameNode再给你一个存储着文件的服务器（DataNode）的列表。
注意：HDFS中只有一个NameNode （除非使用ZooKeeper），也就是意味着如果NameNode失效了，整个HDFS也就失效了。</p>

<p><strong>DataNode
</strong>存放HDFS数据的节点，一般来说，HDFS都有多个DataNode，一个数据会在不同的DataNode上存储多份，以防止部分节点失效后数据丢失。DataNode启动后，会一直试图通知NameNode，以便让NameNode知道它的存在。</p>

<p><strong>SecondaryNameNode
</strong>为了弥补NameNode单点失效的缺点，可以在一台单独机器上配置SecondaryNameNode。不过，SecondaryNameNode只是保存一些记录点（check point），并不会对数据进行冗余保存。</p>

<h3>MapReduce计算模型中的重要概念：</h3>

<p><strong>TaskTracker
</strong>集群中真正执行计算的节点，它的操作包括：Map、Reduce以及Shuffle。每个TaskTracker都设置了一系列的slot，表示这个TaskTracker可以同时接受任务的数量。</p>

<p><strong>JobTracker
</strong>分发MapReduce任务的节点。这个（活动的）JobTracker在一个MapReduce服务中只有一个，因此JobTracker也是单点失效的，如果JobTracker失效了，所有TaskTracker中的任务都会停止。</p>

<p>JobTracker和TaskTracker的交互过程：</p>

<ul>
<li><p>用户提交一个MapReduce任务（Job）给JobTracker</p></li>
<li><p>JobTracker与NameNode通信，以确定数据的位置</p></li>
<li><p>根据数据的位置，定位那些1）在数据节点或者在数据节点附近 2）有可用slot的TaskTracker</p></li>
<li><p>JobTracker向TaskTracker提交对应的任务</p></li>
<li><p>JobTracker开始监控TaskTracker，如果监控不到TaskTracker的心跳，或者TaskTracker上面执行的任务失败，就将任务提交到其他TaskTracker</p></li>
<li><p>当TaskTracker上的任务完成后，JobTracker会更新它的状态</p></li>
</ul>


<p>嗯，差不多就这么多吧，有时间再深入研究研究！</p>

<p>&mdash;EOF&mdash;</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/10/29/some-programmer-job-summary/">程序员求职的一些总结</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-10-29T19:24:42+08:00" pubdate data-updated="true">Oct 29<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/10/29/some-programmer-job-summary/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/10/29/some-programmer-job-summary/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>从九月底到现在，本人历时一个多月的求职之路算得上基本结束了。回顾整个过程，经历了许多，感觉既辛苦又幸运，整体来说还是蛮好玩的。既然在整个过程中经历了许多事情，自己还是写一些东西吧，一方面是对自己的总结和反省，另一方面也算是对学弟学妹将来找工作的一个参考吧。</p>

<h3>不要“海投”</h3>

<p>在求职期间，千万不要见到是跟自己专业相关的公司就去投简历。第一，现在投简历不是直接发个简历就完事的，每投一个公司，自己就要从头到尾填一遍信息，很是浪费时间；第二，之前投了太多公司，到时候各种宣讲会、笔试、面试就会有很多冲突，即使没有冲突，你的时间也会排得满满的，整天疲于奔命，根本没有时间用来准备专业知识。我建议，一般选择6~8家公司就可以了。
另外，如果宣讲会只是宣讲会，之后没有投简历、笔试等环节的话，那就没什么必要去了，能听到的信息在网上也能找到的，除非你想要宣讲会上发的小礼品。。。</p>

<h3>选公司要有梯度</h3>

<p>选择要有梯度，这让我突然想起了高考填报志愿的时候，老师就教导我们选学校要有梯度，学校之间拉开水平。选公司的时候，也是同样的道理，可以把公司根据自己的实力分为三个等级。第一等级的公司，基本上是十拿九稳可以拿到offer的，俗称保底offer；第二等级的公司，虽然竞争也很大，但是自己通过前期的准备和复习，可以搞定的概率还是比较大的；第三等级的公司，就是业内一流的公司，如果能进这样的企业，将会对自己的职业生涯有很大的正面影响，这样的企业，可以尽全力试一试，虽然很难进，但是如果不试一下，未免就有点遗憾了。</p>

<h3>有针对性的准备</h3>

<p>每个公司考核求职者的侧重点都不一样，有的偏C/C++，有的偏Java，有的偏逻辑和算法，有的偏项目经验，有的偏网络，有的还会重点考察外语能力。我们求职前期，可以把大体都会考察到的知识点都粗略看一边。等到要进行笔试/面试的前几天，就可以有针对性的准备了，看看网上关于该公司的笔经/面经，把出现次数很多的题目重点看一看，把该公司的整个招聘流程的风格了解下，到时候可以心里有底、处变不惊。</p>

<h3>动手写代码</h3>

<p>可能许多人在复习专业知识的时候，都是抱着几本书看，但是这样是不够的。想一想，作为程序员，最基本的工作是什么？不就是编代码嘛。现在但凡要求高一点的公司，都会让你在面试的时候，现场写代码的。（我的情况是，有三次面试，让我现场在纸上写代码，还有一次电话面试，让我写出可以运行的程序，一小时后交给面试官）所以，复习专业知识的时候，一定要尽量让自己在电脑或纸上写出该部分的程序，不写不知道，一写才发现自己有许多细节没考虑到。并且，尽量自己多写几遍，可能一开始写需要40分钟甚至1小时，只有多多练习，在面试的时候才能在20分钟左右熟练的写出令面试官满意的代码。</p>

<h3>面试时一般不用穿正装</h3>

<p>一开始准备求职之前，我还在想要不要准备一套正装，可以等自己经过了1、2次面试之后，发现完全没有这个必要。我面试的行头一般就是衬衫+牛仔裤+运动鞋，（有一次有家公司突然通知我当天去面试，结果我只好穿着当天的一套运动装就去了。。。）我感觉作为搞技术的去应聘，穿的干净、整洁就可以了，不要搞得太正规，除非你平时就是一直穿着正装的。（嗯，DCC就是这样的 :&ndash;) ）</p>

<h3>至少有一个自己真正参与的项目</h3>

<p>“真正参与”是什么意思，相信大家都懂的！可能你不是项目的leader，你只是负责其中一部分功能，但你应该有“主人翁”意识嘛，项目是什么背景的，用了哪些技术、哪些框架，难点在哪，最有挑战性的地方是什么，有什么优化的措施，这些问题你都应该有所了解。在参与的项目当中，至少有一个项目你能够很清楚的回答出以上这些问题。几乎在所有面试的时候，面试官也都会问你这些问题。
但是，可能很多人都有这样的困惑，那就是平常没有机会做项目，或者做的项目都是跟公司的业务不相关的，那怎么办？我建议大家平常利用业余时间，一个人或者几个人多做些小项目，总之多创造些实践的机会。这些实践可能对于现在来说好像不是必需的，但是多实践、多总结，对你的前途影响还是很大的，也算是一种培养自信的方式。</p>

<h3>有一个技术博客</h3>

<p>强烈建议大家弄一个自己的技术博客，把自己平时的总结、对于行业的看法等都记录在上面，这是一种技术积累、整理思路的好方法。对于一般只是想记录写文字，对其他没有要求的同学，搞个免费的博客就可以了；如果想要一个独立的博客域名的话，那就弄个虚拟主机，每年付个域名费和服务器空间费用就可以了；更高级的，那就整个VPS，在上面自己搭个博客，正好还能练练Linux下的操作，而且如果有些什么小项目的话，还能直接放到上面，大家就都可以用啦。
说起来也巧，我在一次面试的过程中，面试官看到我简历上面写有自己的技术博客，就直接在他的电脑上访问了一下我的博客，还饶有兴趣的问了我一些博客文章里面涉及到的技术问题，因为都是自己写的，基本上答得都没什么问题。 可以看出，单从这一点来说，面试官对我的面试表现还是比较满意的。</p>

<p>嗯！想要总结的基本上就是这么多，欢迎拍砖！</p>

<p>&mdash;EOF&mdash;</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/09/21/for-programmers-should-go-a-little-bit-of-how-the-business-views/">对于程序员应该去怎样的企业的一点点看法</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-09-21T14:51:23+08:00" pubdate data-updated="true">Sep 21<span>st</span>, 2011</time>
        
           | <a href="/blog/2011/09/21/for-programmers-should-go-a-little-bit-of-how-the-business-views/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/09/21/for-programmers-should-go-a-little-bit-of-how-the-business-views/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>平时我就在想，我们这些程序员，或者说是写代码的，应该去怎样的企业呢？去怎样的企业，使我们能有长远的发展？去怎样的企业，让我们能为社会贡献的更多？最近自己都在找工作，我也不得不面对这样的问题。对我来说，期望值从高到低应该是这样一个顺序：</p>

<h4><strong>一流研究机构</strong>（微软亚洲研究院、Yahoo! 研究院、IBM研究院）</h4>

<p>创新，是改变世界、使得社会得以不断发展的一个重要的因素，而研究机构正是孕育创新摇篮。研究机构里面的研究成果，可能只是一个设想、一个原型，不一定能够立即投入到应用当中。不过一旦研究出点什么，则会对我们的生活有着本质的影响。想起前段时间在南京软件博览会上玩的Kinect，就让人不由的感受到了创新对于改变人们生活方式的力量。</p>

<p>在我的想象当中，一流研究机构里面员工的工作方式应该是：一群人在几乎没有压力的情况下，根据自己的兴趣方向，查阅大量文献资料，找到有意义的创新点，自己编码做出原型系统并不断改进，然后重复上述步骤。</p>

<p>能够在几乎无压力的情况下做自己感兴趣的事情，自己喜欢的事情就是自己的事业，这应该就是最理想的情况了。但是，一流的研究机构对于员工的要求也是及其严格的（这似乎已经大大超出程序员的职责了），你要有深厚的科研能力、扎实的数学功底、缜密的逻辑思维，而且还要有相当的编程能力，能同时具备这些素质的人，很少很少！</p>

<h4><strong>中大型互联网公司</strong>（Google、百度、腾讯、阿里巴巴、网易、淘宝）</h4>

<p>这个时代毕竟是Web的时代，Web已经是无处不在了，所以从事互联网行业还是很有前途的。互联网的主要用户是和我们一样，都是年轻人。互联网公司中的员工，绝大部分也是年轻人。年轻人嘛，都是希望自由、平等、不受拘束，所以公司的氛围一般都是比较轻松的，人与人之间的交流也比较平等、单纯。而且，由于互联网行业的特点，一旦有了较高的、稳定的用户量，公司将会有较快的发展速度，员工就能在这个过程中与公司一同成长，能够经历很多，也能学到很多。</p>

<p>其中，对于那些大型互联网公司，用户量庞大并且稳定，已经找到很好的盈利点，肯定是饿不死的。不过，公司里面的人员机构也会相对臃肿一些，员工在里面可能只会接触到其中的很小一块，不会一开始就了解公司系统的整体构架，但应该会做的比较深。</p>

<p>而那些还处在发展中阶段的中型互联网公司，刚刚起步，员工在里面能经历到公司发展的各个阶段，也能在一开始就了解公司系统的各个方面。不过，在这种公司冒的风险就要稍微大一点了，万一外部或者内部环境出了状况，公司一口气上不来，就。。。</p>

<h4><strong>国外著名软件公司</strong>（微软、IBM、Oracle）</h4>

<p>谁叫计算机是外国人发明出来的呢，外国（尤其是美国）在计算机这一块还是遥遥领先于其他国家的，他们经历了电脑从无到有、PC普及、以及目前互联网的时代。我想不管是理论上、技术上，还是整个的氛围，都比国内高不止一个档次。这些国外著名的软件公司，历史悠久，资金雄厚，技术方面更是不用说。因此，如果能进入这些公司，可以感受到国际一流的技术和氛围，也有机会能与全世界各国的人士交流，整个视野也会比较开阔。而且，这些公司绝大部分都会落户于北京、上海这样的中国一线城市，对于想在一线城市打拼的人来说应该是个不错的选择。</p>

<p>当然，正如前面说到的，公司一旦大了，就难免显得臃肿，每个员工在里面一开始都只负责其中的一小块。而且，其中有些公司，真正的核心技术还是在国外的总部进行研发的，中国的公司可能就负责一些周边的系统，有的甚至是处理一些服务性质的工作，如果是这样的话，那就没什么意思了。</p>

<h4><strong>大型非软件公司的IT部门</strong>（中兴、华为、移动、银行）</h4>

<p>有些大公司，不是纯粹的软件公司，有可能是做电信的或者金融，但其中的IT部门也会有很大的规模。在这些公司的话，工作就会集中在某一个行业里了，做的深的话就可以成为某一个行业的IT专家了，优点是可以凭经验吃饭，工作时间越长越有竞争力，缺点就是你只能局限在一个小圈子甚至几个同类公司了。里面有些公司，业务散得很大，需要大量的人，所以进去相对容易一些，比如中兴、华为。（不过至今未收到中兴的面试通知，好歹给我个保底啊！）另外一些公司，不需要大量的人力，想进去就困难的多了，比如中国移动或者一些银行。（上次在网上看了摩根斯坦利的技术笔试题，感觉对员工的英语、数学、逻辑以及技术的要求都非常高。）</p>

<h4><strong>创业公司</strong></h4>

<p>这两年在中国，创业的氛围还是挺浓的。我周围就有一些同学一毕业或者工作2、3年就去创业了，有的不时还诱惑我，希望我跟他们一起干。上次我还意外的去了家创业公司看了看，里面的老板是CMU毕业的博士，在国外工作了二十多年，然后回国创业。公司的技术氛围还不错，跟老板聊了聊，感觉人家还是挺有想法的。</p>

<p>在创业公司工作的话，几乎就是从零开始，好处很明显，如果公司起来了，你就是创始人之一啦！但是，在创业公司压力也很大，公司说不定随时都会倒掉。如果没有足够的拼劲和毅力的话，不要选择创业公司；如果没有自己的想法，只想完成别人给你的任务，也不要选择创业公司；如果自己技术不过关，那更不要选择创业公司。因为在创业公司，每一位员工都是要有贡献的，是容不得人吃闲饭的。</p>

<h4><strong>外包公司</strong>（南大富士通、东软）</h4>

<p>外包嘛，大家都懂得，就是一些公司把非核心技术方面的东西拿给这些公司来做。如果有固定的客户或者就是某个公司的“内包”的话，那就不愁没项目接，不然就要去到处拉项目了。做外包项目，基本上都是些大同小异的东西，最终只要按合同上写好的要求完成就可以了。在外包公司里面，我感觉技术方面学不到很多，不过工程方面的知识和经验倒还是可以学到不少的。</p>

<p>嗯，大概就是这些吧！本人能力有限，能想到的大概是这么多，肯定有许多考虑不周的地方，欢迎拍砖！</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/09/08/speaking-from-a-recent-job/">从最近找工作说起</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-09-08T15:26:25+08:00" pubdate data-updated="true">Sep 8<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/09/08/speaking-from-a-recent-job/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/09/08/speaking-from-a-recent-job/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>求职季开始了，大家都忙碌起来了，完善自己的简历，进行网申，复习专业知识，准备笔试和面试。这个过程，其实也是对自己整个大学生涯的回顾和总结。看看自己的简历，看看自己以前到底做过些什么，到底做过些什么有意义的事情，到底做过些什么没有任何人逼你、你却乐在其中、做完后很有成就感的事情。这些事情，对我来说，有，但不多。</p>

<p>还是来说说最近碰到的一些事情以及一些感悟吧。</p>

<p>写简历时，我发现一个很严重的问题：在研究生阶段，自己的能力没有得到什么提高，至少没有明显的提高。之前准备上研究生的时候，总是会憧憬着研究生阶段会有许多项目做，生活会很忙碌、很充实。可是没想到，原来研究生阶段大多都是自学成才！（我周围都是这样的，不代表所有情况）研究生阶段，说白了就是给导师打工，很可惜，导师一般情况下给你不会是实际的项目，而是让你些各种策划书，查阅论文，搜集资料。至于学术研究，大家都是自己搞自己的一部分，遇到问题基本上也没人可以讨论的，自己研究的东西导师可能也不是很了解。相比较而言，还是本科的时候更自在、更充实！但是，有些事情自己还是要肯定一下自己的。比如研究生阶段还是去做了POJ和USACO上面的题目，搞了个人的技术博客，仍然坚持关注业内的动态，去考了中级口译（虽然口试部分没通过 :( ），也还是算在不停折腾的，没有完全打酱油。</p>

<p>当然，我也不能说我选择上研究生是错误的，无论选哪一条路，只要走好了，前途都会很光明的。读研也是有很多好处的，例如没有工作那么辛苦，有一些自由的时间，可以做一些自己感兴趣的事情（当然，这里感兴趣的事情，是与专业相关的，不是玩游戏、看电视剧这些事情）。反正有利有弊吧，就看你怎么做了。</p>

<p>另外，最近在找工作时也发生了一件令人哭笑不得的事情。教研室一X同学看许多公司招聘职位的要求里面都需要熟悉Python，他从没学过Python，但居然在简历里面写上“熟悉Python”投给了应聘的公司。为了不露馅，这两天配置了一下Python环境，看了几页书，写出个“Hello，world”，他就表示自己已经熟悉Python了。。。你说你之前学过些什么，现在记不清了，复习一下，这还情有可原，但在简历里面写着熟练掌握的东西，自己居然从来没学过，这就有点太过分了。你看中国的教育把X同学折磨成什么样了，这简直就是应试的另一个极端体现。不是因为Python是一门简洁的语言，不是因为Python可以高效的解决平时开发中的种种问题，而是因为招聘单位要求熟悉Python，所以他才要学习Python，真是让人觉得可笑又可悲。</p>

<p>当然，我也相信，许多同学（包括我）都会或多或少的给简历加点“水分”，添点色彩，谁又能完全免俗呢？但是，我希望能在这个复杂的世界里面能尽量保持一份单纯，怀着单纯的喜爱做出一些觉得对自己、对别人有意义的事情，并且希望能把这个世界变得更好。世界的复杂我们也许无法改变，但我们能够改变自己，或者说是改善自己，这是在我们力所能及的范围之内的。我们从小学、中学、大学、或者再到研究生，难道得到的仅仅是一个个学历，一张张纸吗？绝对不应该是这样！学习的目的之一，应该就是让我们有这样的理想、这样的动力，让我们在这纷繁的世界中保持相对的单纯，而不是在这个世界随波逐流，与这个世界“同流合污”。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/08/16/hadoop_easy_test/">Hadoop极精简运行实验</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-08-16T14:18:33+08:00" pubdate data-updated="true">Aug 16<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/08/16/hadoop_easy_test/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/08/16/hadoop_easy_test/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>出于对海量数据处理的兴趣以及毕设实验的要求，最近空闲时间小搞了一下Hadoop。对Hadoop不了解的同学，可以看<a href="http://hadoop.apache.org/">这里</a>。简单的说，它是一个利用MapReduce编程模型进行分布式大规模数据处理的框架。在Hadoop中，数据都表示为键/值对的形式，以便用MapReduce进行处理。MapReduce的思想十分简单，数据的处理过程分为两个阶段：map和reduce。map过程是将value（源数据）映射到不同的key中，这样所有数据就变成了key/value的集合，一个key会对应多个value；而在reduce阶段，则将每一个key的value集合进行处理，最后也同样得到key/value的集合，但这里一个key对应的一个value（计算结果）。</p>

<p>对于使用Hadoop的人来说，其实我们只需编写map和reduce函数，以及一个驱动程序即可，至于Hadoop是如何将多个value统一到一个key中，并且对这些value进行分组、排序，我们可以不考虑（只是暂时的）。由于手边没有“海量”数据，我只好自己造了。简单起见，我直接以键值对的形式生成了数据，而场景就是找到每个key的最大value。</p>

<p>我们首先来看map函数：</p>

<pre><code>package main;

import java.io.IOException;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Mapper.Context;

/*
* map function
* the 4 class arguments of Mapper mean: input key, input value, output key, output value
*/
public class FindMaxInKeyMapper extends Mapper&lt;LongWritable, Text, IntWritable, IntWritable&gt;
{

    public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException
    {
        String line = value.toString();
        String[] results = line.split(" ");
        int id, num;
        try
        {
            id = Integer.parseInt(results[0]);
            num = Integer.parseInt(results[1]);
        }
        catch (Exception ex)
        {
            return;
        }
        // add key/value
        context.write(new IntWritable(id), new IntWritable(num));
    }
}
</code></pre>

<p>map阶段是数据的整理阶段，基类Mapper中的类型参数分别表示：输入的key、value类型，以及输出的key、value类型。注意，这里输出的key/value与MapReduce中的概念是一致的，而输入的key/value则不是，一般来说，输入的key表示输入数据的偏移量，而输入的value表示数据本身。所以，map阶段的主要任务就是把输入的value（源数据）表示成key/value的形式，供下一步的reduce使用。我们这个例子中，只需将表示一行的String分别分解成两个int就可以了。</p>

<p>好，再来看看reduce函数：</p>

<pre><code>package main;

import java.io.IOException;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.Reducer.Context;

public class FindMaxInKeyReducer  extends Reducer&lt;IntWritable, IntWritable, IntWritable, IntWritable&gt;
{
    /*
     * reduce function
     * find the max value in values (in the same key)
     */
    public void reduce(IntWritable key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException
    {
        int maxValue = Integer.MIN_VALUE;
        for (IntWritable value: values)
        {
            maxValue = Math.max(maxValue, value.get());
        }
        context.write(key, new IntWritable(maxValue));
    }
}
</code></pre>

<p>reduce阶段就是数据进行实质处理的阶段了，它的输入源于map阶段，是一个key和一个value的集合，它的输出就是一个key/value对。输入输出的key/value类型可以各不相同，只要map输出的key/value类型和reduce输入的一样就可以了。在我们的例子里面，只要在values里面找到一个最大的，然后以同样的key和那个最大的value最为输出、放入context即可。</p>

<p>最后，写一个驱动程序（不是设备的驱动程序，你懂的）：</p>

<pre><code>package main;

import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;

public class FindMaxInKey { 

    public static void main(String[] args) throws Exception{
        if ( args.length != 2 )
        {
            System.err.println("Usage: FindMaxInKey &lt;input path&gt; &lt;output path&gt;");
            System.exit(-1);
        }

        Job job = new Job();
        job.setJarByClass(FindMaxInKey.class);

        FileInputFormat.addInputPath(job, new Path(args[0]));
        FileOutputFormat.setOutputPath(job, new Path(args[1]));

        job.setMapperClass(FindMaxInKeyMapper.class);
        job.setReducerClass(FindMaxInKeyReducer.class);

        job.setOutputKeyClass(IntWritable.class);
        job.setOutputValueClass(IntWritable.class);

        System.out.println("start working");
        System.exit(job.waitForCompletion(true) ? 0: 1);
    }

}
</code></pre>

<p>驱动程序的工作也很简单，设置一下Map类、Reduce类、数据输入输出路径，基本上就可以了。好，下面，跑起来！</p>

<p>如果在配置中采用默认设置，Hadoop底层的文件系统就是本地操作系统的文件系统。不过，一般都要设置成HDFS分布式文件系统的。（肯定啊，否则Hadoop有个什么意义）将工程打成jar包，然后敲入命令：</p>

<blockquote><p>quxiao@ubuntu1:~/hadoop/bin$ ./hadoop jar /home/quxiao/workspace/HadoopTest/HadoopTest.jar main.FindMaxInKey /user/quxiao/data.in /user/quxiao/outputdata</p></blockquote>

<p>就可以看到命令行中提示map和reduce的完成百分比，在Hadoop自带的监控系统可以更直观的看到运行的信息。</p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/08/Screenshot-2.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/08/Screenshot-2-1024x573.png" alt="" /></a></p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/08/Screenshot-3.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/08/Screenshot-3-1024x573.png" alt="" /></a></p>

<p>运行之后，程序的输出是这种形式：</p>

<blockquote><pre><code>0 2147435993
1 2147464484
2 2147479158
3 2147458512
4 2147389924
5 2147416503
6 2147378427
7 2147478518
8 2147433586
9 2147435229
10    2147381593
11    2147463851
12    2147454928
13    2147462197
14    2147480411
15    2147481870
16    2147469297
17    2147435232
18    2147439681
19    2147437661
</code></pre></blockquote>

<p>好！这个极精简实验就算是运行成功了。初步来看，用Hadoop做数据分析还是挺简单的，你不用担心数据的分组、排序、存储，以及许多分布式相关的细节，只要写好map和reduce函数即可。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/25/deap/">双端堆</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-07-25T14:17:06+08:00" pubdate data-updated="true">Jul 25<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/07/25/deap/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/07/25/deap/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>之前有同学问我，怎么在一个集合中高效的找到最大以及最小的元素？（注意，不是总是找最大元素，或者总是找最小元素，而是类似随机的查找最大以及最小元素。）一开始有几种想法：</p>

<p>朴素的想法</p>

<p>把集合遍历一遍，就可以知道最大或者最小元素了，查找复杂度是O(N)，查找并删除的复杂度也是O(N)。</p>

<p>堆结构</p>

<p>用两个堆，一个最大堆，一个最小堆，两个堆各存一份数据。查找最大元素，就在最大堆里面找；查找最小元素，就在最小堆里面找，他们的查找时间复杂度是O(1)，查找并删除的复杂度是O(logN)。但是，怎么“同步”这两个堆呢？即，在最大堆里面删除最小的元素，在最小堆里面删除最大的元素。我们知道的只是：最小（大）元素在最大（小）堆的叶子上。怎么判断节点是叶子呢？下标×2 > size就是叶子，但是叶子上面的元素又不是排序的，查找的复杂度只能是O(N)。所以，这种想法的复杂度还是O(N)。</p>

<p>双端堆（灯，等灯等灯！）</p>

<p>突然想到小倩同学之前好像说过一个叫双端堆的数据结构，可以同时高效的查找最大最小元素。问了下小倩，然后又发现原来最近看的《<a href="http://book.douban.com/subject/3576025/">数据结构基础</a>》上面，就有相关的内容，只不过里面不叫双端堆，而是叫做对称最小-最大堆。（我个人感觉这两种名称讲的就是同一个数据结构）它就可以在O(1)的复杂度的情况下，找到最小（大）元素；O(logN)的情况下找到并删除最小（大）元素。</p>

<p><strong>双端堆的特点</strong></p>

<p>双端堆是一棵满二叉树，最顶端的根是一个虚根，不存放数据。定义element(N)为节点N的所有子孙节点（不包括N本身）的集合，N的左孩子left(N)（如果有的话）是element(N)中最小的元素，右孩子right(N)（如果有的话）是element(N)中最大的元素。</p>

<p>当以下条件成立时，它才是双端堆：</p>

<ul>
<li><p>P1：每个节点的元素小于等于它的右兄弟（如果有）</p></li>
<li><p>P2：对于每个有祖父的节点N，其祖父节点的左孩子小于等于N</p></li>
<li><p>P3：对于每个有祖父的节点N，其祖父节点的右孩子大于等于N</p></li>
</ul>


<p>比如下图就是一个双端堆</p>

<p><img src="http://quxiao.github.io/images/2011-07-25-deap/image_thumb20.png" alt="image" /></p>

<p>下面我们看看实现</p>

<p>既然是一个满二叉树，那么就可以像堆一样有一个数组来表示，下标为n的节点的左右孩子的下标分别为2×n和2×n+1。</p>

<p><strong>插入操作</strong></p>

<p>现将该元素放在树的最后，看有没有满足性质P1，若违反，交换两节点的内容。再看是否满足上面讲的性质P2或者P3，如果满足，就将元素放在当前位置；若没有：</p>

<ul>
<li><p>违反P2，将当前节点与其祖父的左孩子交换，祖父的左孩子变成当前节点；</p></li>
<li><p>违反P3，将当前节点与其祖父的右孩子交换，祖父的右孩子变成当前节点。</p></li>
</ul>


<p>重复进行判断，直至找到合适的位置。</p>

<p>假设插入2，过程如下图：</p>

<p><img src="http://quxiao.github.io/images/2011-07-25-deap/image_thumb21.png" alt="image" />
=>
<img src="http://quxiao.github.io/images/2011-07-25-deap/image_thumb22.png" alt="image" />
=>
<img src="http://quxiao.github.io/images/2011-07-25-deap/image_thumb23.png" alt="image" /></p>

<p>代码如下:</p>

<div>
  <pre><code class='java'>public void insert (T data) throws Exception
    {
        int curIdx = ++ size;
        if ( size &gt;= HEAP_MAX_SIZE )
            throw new Exception();
        int grandpa;
        int parentMin, parentMax;       //爷爷的左右孩子
        while (true)
        {
            //是否有更大的左兄弟
            if ( (curIdx &amp; 1) == 1 &amp;&amp; data.compareTo(heap[curIdx-1]) &lt; 0 )
            {
                heap[curIdx] = heap[curIdx-1];
                -- curIdx;
            }

            grandpa = curIdx &gt;&gt; 2;
            if ( grandpa == 0 )
                break;
            parentMin = grandpa &lt;&lt; 1;
            parentMax = parentMin + 1;
            if ( heap[parentMin].compareTo(data) &gt; 0 )
            {
                heap[curIdx] = heap[parentMin];
                curIdx = parentMin;
            }
            else if ( heap[parentMax].compareTo(data) &lt; 0 )
            {
                heap[curIdx] = heap[parentMax];
                curIdx = parentMax;
            }
            else
                break;
        }
        heap[curIdx] = data;
    }</code></pre>
</div>


<p><strong>删除操作</strong></p>

<p>这里面的删除操作应该是指找到并删除最小（大）元素，找到很容易，最小元素是根的左孩子，最大元素是根的右孩子。但是，删除之后怎么调整以满足双端堆的特性呢？我们以删除最小元素为例，算法如下：</p>

<p>我们将树的最后一个元素暂时放在删除元素的位置，判断两个条件：</p>

<p>是否满足P1，不满足则交换两元素</p>

<p>与其左孩子、以及右兄弟节点的左孩子（如果有的话）比较，是否是最小的，不是则与最小的节点交换。（其左孩子和右兄弟的左孩子是两个次小的节点）</p>

<p>重复以上判断，直至满足这两个条件。</p>

<p>如果删除4的话，过程如下图：</p>

<p><img src="http://quxiao.github.io/images/2011-07-25-deap/image_thumb24.png" alt="image" />
=>
<img src="http://quxiao.github.io/images/2011-07-25-deap/image_thumb25.png" alt="image" />
=>
<img src="http://quxiao.github.io/images/2011-07-25-deap/image_thumb26.png" alt="image" />
=>
<img src="http://quxiao.github.io/images/2011-07-25-deap/image_thumb27.png" alt="image" />
=>
<img src="http://quxiao.github.io/images/2011-07-25-deap/image_thumb28.png" alt="image" /></p>

<p>代码如下：</p>

<div>
  <pre><code class='java'>public T deleteMin () throws Exception
    {
        if ( size &lt; 2 )
            throw new Exception();
        if ( size == 2 )
            return heap[size --];

        T tmp;
        int minChildIdx;
        T data = heap[size --];
        int curIdx = 2;
        T ret = heap[curIdx];
        while ( true )
        {
            if ( (curIdx &amp; 1) == 0 &amp;&amp; curIdx + 1 &lt;= size &amp;&amp; data.compareTo(heap[curIdx+1]) &gt; 0 )
            {
                tmp = heap[curIdx+1];
                heap[curIdx+1] = data;
                data = tmp;
            }
            minChildIdx = curIdx &lt;&lt; 1;
            if ( minChildIdx &gt; size )
                break;
            if ( ((curIdx + 1) &lt;&lt; 1) &lt;= size &amp;&amp; heap[minChildIdx].compareTo(heap[(curIdx+1)&lt;&lt;1]) &gt; 0 )
                minChildIdx = (curIdx + 1) &lt;&lt; 1;
            if ( data.compareTo(heap[minChildIdx]) &gt; 0 )
            {
                heap[curIdx] = heap[minChildIdx];
                curIdx = minChildIdx;
            }
            else
                break;
        }
        heap[curIdx] = data;
        return ret;
    }</code></pre>
</div>


<p>所有代码可以在<a href="http://code.google.com/p/quxiao-source-code/source/browse/#svn%2Ftrunk%2Fdata_structure%2FSMMH%2Fsrc">这里</a>看到。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/21/avl_tree_implimentation/">AVL树初步实现</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-07-21T21:12:20+08:00" pubdate data-updated="true">Jul 21<span>st</span>, 2011</time>
        
           | <a href="/blog/2011/07/21/avl_tree_implimentation/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/07/21/avl_tree_implimentation/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这两天复习数据结构，看到AVL树这一部分，之前这部分一直处于“纸上谈兵”的阶段，表示有些遗憾。趁着最近比较闲，把它实现一下！</p>

<p>还是先讲一下AVL树的基本概念吧。其实，AVL树就是二叉树，与普通二叉树不同的是，它能通过某种操作（“旋转”）使得树保持几乎平衡，这里就是指左子树和右子树的树高差的绝对值&lt;=1。当二叉树是平衡的情况下，在树上的搜索效率就会提高。极端情况下，能从O(N)降到O(logN)。</p>

<p>OK，那么又有哪几种不平衡的情况呢？我们来看一下下面几种情况：</p>

<p>右子树的右子树太“深”</p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/07/image.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/07/image_thumb.png" alt="image" /></a></p>

<p>树往一边倾斜，这是一种常见的不平衡状态。比如把一个已排序的数据插入二叉树就是这种情况。遇到这种情况，如果可以把k2“提”起来就好了。很简单，我们可以把k2作为树根，k1做k2的左孩子，再把B当作k1的右子树。旋转之后可以得到：</p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/07/image1.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/07/image_thumb1.png" alt="image" /></a></p>

<p>这样，树又基本平衡了。左子树的左子树太深的情况可依此类推。这两种情况成为单旋转。</p>

<p>还有一种情况，右子树的左子树太“深”</p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/07/image2.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/07/image_thumb2.png" alt="image" /></a></p>

<p>这样就k2不好“提”了，因为旋转之后，B子树的树高没有改变。把树描述的更加详细一些：</p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/07/image3.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/07/image_thumb3.png" alt="image" /></a> => <a href="http://www.qxavier.me/wp-content/uploads/2011/07/image4.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/07/image_thumb4.png" alt="image" /></a></p>

<p>我们的目标是把k3以及BC放的高一些，以降低整体树高。因为k1&lt;=k3&lt;=k2，那可否让k3来做树根呢？k3做了树根，k1和k2是其左右孩子，AD子树可以不变，B可以作为k1右子树，C可以作为k2左子树，这样就搞定了！</p>

<p>同样，左子树的右子树太深的情况也是类似。这两种情况成为双旋转。</p>

<p>好，用代码实现这些操作！</p>

<p>根据单旋转的图例，两步操作就可以完成：</p>

<ol>
<li><p> k2的左指针指向k1</p></li>
<li><p> k1的右指针指向B</p></li>
</ol>


<p>代码实现就是这样：</p>

<pre><code>AVLTree* singleRotateWithRight(AVLTree* pNode)
{
    if ( pNode == NULL || pNode-&gt;right == NULL )
        return NULL;
    AVLTree* rightNode = pNode-&gt;right;
    pNode-&gt;right = rightNode-&gt;left;
    rightNode-&gt;left = pNode;

    pNode-&gt;height = max(getHeight(pNode-&gt;left), getHeight(pNode-&gt;right)) + 1;
    rightNode-&gt;height = max(getHeight(rightNode-&gt;left), getHeight(rightNode-&gt;right)) + 1;

    return rightNode;
}
</code></pre>

<p>再看双旋转的实现，很奇妙的是，一个双旋转可以用两个但旋转来代替！</p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/07/image5.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/07/image_thumb5.png" alt="image" /></a>=><a href="http://www.qxavier.me/wp-content/uploads/2011/07/image6.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/07/image_thumb6.png" alt="image" /></a> =><a href="http://www.qxavier.me/wp-content/uploads/2011/07/image7.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/07/image_thumb7.png" alt="image" /></a></p>

<p>实现起来相当简单：</p>

<pre><code>AVLTree* doubleRotateWithRight (AVLTree* pNode)
{
    pNode-&gt;right = singleRotateWithLeft(pNode-&gt;right);
    return singleRotateWithRight(pNode);
}
</code></pre>

<p>插入操作怎么实现呢？其实就是在普通二叉树的插入操作之后，加入判断是否不平衡，若不平衡，判断是哪种情况，进行相应旋转操作。</p>

<pre><code>AVLTree* insert(int data, AVLTree* pNode)
{
    if ( pNode == NULL )
    {
        pNode = new AVLTree();
        pNode-&gt;data = data;
        pNode-&gt;height = 0;
        pNode-&gt;left = pNode-&gt;right = NULL;
    }
    else if ( data &lt; pNode-&gt;data )
    {
        pNode-&gt;left = insert(data, pNode-&gt;left);
        if ( getHeight(pNode-&gt;left) - getHeight(pNode-&gt;right) == 2 )
        {
            if ( data &lt; pNode-&gt;left-&gt;data )
            {
                pNode = singleRotateWithLeft(pNode);
            }
            else
            {
                pNode = doubleRotateWithLeft(pNode);
            }
        }
    }
    else if ( data &gt; pNode-&gt;data )
    {
        pNode-&gt;right = insert(data, pNode-&gt;right);
        if ( getHeight(pNode-&gt;right) - getHeight(pNode-&gt;left) == 2 )
        {
            if ( data &gt; pNode-&gt;right-&gt;data )
            {
                pNode = singleRotateWithRight(pNode);
            }
            else
            {
                pNode = doubleRotateWithRight(pNode);
            }
        }
    }

    return pNode;
}
</code></pre>

<p>好吧，先写这么多，性能对比以后再写。全部实现代码可以在<a href="http://code.google.com/p/quxiao-source-code/source/browse/#svn%2Ftrunk%2Fdata_structure%2FAVLTreeCPP%2FAVLTreeCPP">这里</a>看到。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/15/usaco-section-4-1-cryptcowgraphy/">USACO Section 4.1 Cryptcowgraphy</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-07-15T00:00:54+08:00" pubdate data-updated="true">Jul 15<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/07/15/usaco-section-4-1-cryptcowgraphy/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/07/15/usaco-section-4-1-cryptcowgraphy/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>题目大意：</p>

<p>一种字符串加密算法，即在原有字符串的任意位置插入C、O、W，C的下标 &lt; O的下标 &lt; W的下标，将C、O之间和O、W之间子串交换，得到新的字符串。给你一个字符串，问其是否是对字符串Begin the Escape execution at the Break of Dawn经过多次加密过后的字符串。</p>

<p>我的思路：</p>

<p>首先，原字符串中并没有COW三个字母，所以不用判断COW是属于原先的字符还是加密时加上的字符，这样简单很多。另外，对于已加密的字符串，只要找到任意一组COW，交换CO和OW之间的子串，再把COW删掉，得到的字符串就是可能的一种原字符串，再这样递归下去，直到不可能的情况或者字符串变为Begin the Escape execution at the Break of Dawn。</p>

<p>在搜索时，有几种减枝可以排除目前的字符串：</p>

<ul>
<li><p>如果目前字符串的长度不等于原串长度+3×k，排除。（其实只需在开始时判断一次即可）</p></li>
<li><p>如果目前字符串中COW三个字母的数目不相等，排除。（也可只判断一次）</p></li>
<li><p>如果任意COW字符之间的子串，没有出现在原串中，排除。（这个减枝很重要，但是没想到，不应该啊）</p></li>
<li><p>字符串中，所有出现COW的地方，C应该排在第一个，W应该排在最后一个。否则，无法还原成原字符串。</p></li>
<li><p>用hash来判断目前字符串之前有没有出现过。（hash表的大小选择很关键，选的太大，可能会超时，选的太小，可能会WA）</p></li>
</ul>


<p>另外，枚举COW时的搜索方式也很重要。如果每一层都会从i到len，像这样：</p>

<pre><code>    for (i = 0; i &lt; l; i ++)
    {
        if ( str[i] != 'C' )
            continue;
        for (j = i + 1; j &lt; l; j ++)
        {
            if ( str[j] != 'O' )
                continue;
            for (k = j + 1; k &lt; l; k ++)
            {
                if ( str[k] != 'W' )
                    continue;
                if ( CheckStr( RestoreString(str, i, j, k)) )
                    return true;
            }
        }
    }
</code></pre>

<p>很容易就超时了。</p>

<p>但是，如果先把所有COW的下标先记下来，再在每一层枚举它们的下标，像这样：</p>

<pre><code>    for (i = 0; i &lt; cNum; i ++)
    {
        for (j = 0; j &lt; oNum; j ++)
        {
            for (k = 0; k &lt; wNum; k ++)
            {
                if ( cIdx[i] &lt; oIdx[j] &amp;&amp; oIdx[j] &lt; wIdx[k] )
                {
                    if ( CheckStr( RestoreString(str, cIdx[i], oIdx[j], wIdx[k])) )
                        return true;
                }
            }
        }
    }
</code></pre>

<p>就会快很多。</p>

<p>好了，废话不多说，直接上代码：</p>

<pre><code>unsigned int elf_hash(string str)
{
    unsigned long h = 0, g, i, l;
    l = str.length();
    for (i = 0; i &lt; l; i ++)
    {
        h = (h &lt;&lt; 4) + str[i];
        if (g = h &amp; 0xf0000000l)
            h ^= g &gt;&gt; 24;
        h &amp;= ~g;
    }
    return h % HASH_NUM;
}

//COW的数目是否相等，以及数目是多少
//其实跟CheckStr中的判断有重复，还可以优化！
int CheckCOWNum (string str)
{
    int i, l;
    int nC, nO, nW;
    nC= nO = nW = 0;
    l = str.length();

    for (i = 0; i &lt; l; i ++)
    {
        if ( str[i] == 'C' )
            ++ nC;
        else if ( str[i] == 'O' )
        {
            ++ nO;
        }
        else if ( str[i] == 'W' )
        {
            ++ nW;
        }
    }
    if ( nC == nO &amp;&amp; nO == nW )
        return nC;
    else
        return -1;
}

//还原加密的字符串
//idx1 &lt; idx2 &lt; idx3
string RestoreString (string now, int idx1, int idx2, int idx3)
{
    string pre = "";
    int i, l;
    l = now.length();
    pre = now.substr(0, idx1);
    pre += now.substr(idx2+1, idx3-idx2-1);
    pre += now.substr(idx1+1, idx2-idx1-1);
    pre += now.substr(idx3+1, l-idx3-1);

    return pre;
}

bool CheckBetweenCOW (string str)
{
    int lastIdx;
    int i, l;
    lastIdx = -1;
    l = str.length();
    for (i = 0; i &lt; l; i ++)
    {
        if ( str[i] == 'C' || str[i] == 'O' || str[i] == 'W' )
        {
            if ( finalStr.find(str.substr(lastIdx + 1, i - lastIdx - 1)) == string::npos )
            {
                return false;
            }
            lastIdx = i;
        }
    }
    return true;
}

bool CheckStr (string str)
{
    if ( str == finalStr )
        return true;

    int hash;
    hash = elf_hash(str);
    if ( hashVisited[hash] )
        return false;
    hashVisited[hash] = true;

    int i, j, k, l;
    int cNum, oNum, wNum, allNum;
    int cIdx[NUM], oIdx[NUM], wIdx[NUM], allIdx[NUM];
    cNum = oNum = wNum = allNum = 0;
    l = str.length();

    //记录C O W的下标
    allIdx[allNum++] = -1;
    for (i = 0; i &lt; l; i ++)
    {
        if ( str[i] == 'C' )
        {
            cIdx[cNum++] = i;
            allIdx[allNum++] = i;
        }
        else if ( str[i] == 'O' )
        {
            oIdx[oNum++] = i;
            allIdx[allNum++] = i;
        }
        else if ( str[i] == 'W' )
        {
            wIdx[wNum++] = i;
            allIdx[allNum++] = i;
        }
    }
    if ( allIdx[allNum-1] != l - 1 )
        allIdx[allNum++] = l;

    //所有出现COW的地方，C应该排在第一个，W应该排在最后一个。否则，无法还原成原字符串
    if ( cNum )
    {
        if ( cIdx[0] &gt; oIdx[0] || cIdx[0] &gt; wIdx[0] )
            return false;
        if ( wIdx[wNum-1] &lt; cIdx[cNum-1] || wIdx[wNum-1] &lt; oIdx[oNum-1] )
            return false;
    }

    //任意COW之间的子串都应该在原串中出现过
    for (i = 0; i &lt; allNum-1; i ++)
    {
        if ( finalStr.find(str.substr(allIdx[i]+1, allIdx[i+1]-allIdx[i]-1)) == string::npos )
            return false;
    }

    for (i = 0; i &lt; cNum; i ++)
    {
        for (j = 0; j &lt; oNum; j ++)
        {
            for (k = 0; k &lt; wNum; k ++)
            {
                if ( cIdx[i] &lt; oIdx[j] &amp;&amp; oIdx[j] &lt; wIdx[k] )
                {
                    if ( CheckStr( RestoreString(str, cIdx[i], oIdx[j], wIdx[k])) )
                        return true;
                }
            }
        }
    }

    //这样就会很慢。。。
    //  for (i = 0; i &lt; l; i ++)
    //  {
    //      if ( str[i] != 'C' )
    //          continue;
    //      for (j = i + 1; j &lt; l; j ++)
    //      {
    //          if ( str[j] != 'O' )
    //              continue;
    //          for (k = j + 1; k &lt; l; k ++)
    //          {
    //              if ( str[k] != 'W' )
    //                  continue;
    //              if ( CheckStr( RestoreString(str, i, j, k)) )
    //                  return true;
    //          }
    //      }
    //  }

    return false;
}

void Solve ()
{
    if ( (str.length() - finalStr.length()) % 3 != 0 )
    {
        printf("0 0\n");
        return;
    }

    int nCOW = CheckCOWNum(str);
    if ( nCOW == -1 || !CheckStr(str) )
    {
        printf("0 0\n");
        return;
    }
    printf("1 %d\n", nCOW);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/05/usaco-section-4-1-fence-loops/">USACO Section 4.1 Fence Loops</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-07-05T21:56:12+08:00" pubdate data-updated="true">Jul 5<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/07/05/usaco-section-4-1-fence-loops/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/07/05/usaco-section-4-1-fence-loops/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>题目大意：</p>

<p>有N个栏杆，告诉你它们的长度以及它们各自的连接情况，求出围成的最短的封闭空间的周长。其中，1 &lt;= N &lt;= 100，栏杆长度Ls，1 &lt;= Ls &lt;= 255，每个栏杆至多与另外8跟栏杆相连。</p>

<p>思路：</p>

<p>就是在图中找最小环。因为N（即边数）最大为100，即使通过枚举每个点进行搜索，复杂度也不过为100×100，可以采用搜索。枚举每个栏杆的一端顶点，如果搜索到这根栏杆的另一端顶点，那么就意味着找到环了，更新答案。</p>

<p>这题思路倒很简单，但是由于输入是以边为中心的，所以实现起来稍稍有点困难。我将每个栏杆的两个顶点定义为s端和e端，如果从某栏杆a的s端出发，那么枚举与a的e端相连的栏杆b，再判断是b的哪一端连接着a，枚举b的另一端，以此类推。</p>

<p>还有一些减枝和优化，比如：</p>

<ol>
<li><p> 收到<a href="http://www.qxavier.me/2011/07/01/usaco-section-4-1-fence-rails/">上一题</a>的启发，可以限定搜索深度，因为组成环的边数少，周长小的概率就比较大。</p></li>
<li><p> 当前的长度和大于等于目前的答案，退出。</p></li>
<li><p> 当前栏杆之前访问过，退出。</p></li>
<li><p> 只需枚举栏杆的一端即可，因为s->e和e->s的效果是一样的。</p></li>
</ol>


<p>看了USACO的官方分析，貌似处理的比较复杂，先把输入转化成标准的图，再对于每一条边，先删除它，然后用Dijkstras算法求最短路。这种方案相交于我的思路，没有太多优越性，但是编码的复杂度却也高。-_&ndash;</p>

<p>关键代码如下：</p>

<pre><code>const int N = 101;

int n;
int len[N];
vector&lt;int&gt; childSeg[N][2];     //[0] s end; [1] e end
short int connect[N][N];        //connect[a][b] = 0/1 means the s/e end of a connects with seg b
int curMax = 1&lt;&lt;20;
int visited[N];

/*
seg为负，表示当前节点为seg的s端
seg为正，表示当前节点为seg的e端
*/
void Search(int seg/*negtive s end; positive e end*/, int curLen, int destSeg, int depth)
{
    if ( seg == destSeg &amp;&amp; curLen != 0)
    {
        if ( curLen &lt; curMax )
            curMax = curLen;
        return;
    }
    if ( !depth )
        return;
    if ( curLen &gt;= curMax )
        return;

    int segId = abs(seg);
    if ( visited[segId] )
        return;
    visited[segId] = 1;
    int childSegId;
    //whichEnd, segId的另一端
    int whichEnd = 0;
    if ( seg &lt; 0 )
        whichEnd = 1;
    int i;
    for (i = 0; i &lt; childSeg[segId][whichEnd].size(); i ++)
    {
        childSegId = childSeg[segId][whichEnd][i];
        //从childSegId的另一端继续搜索
        if ( connect[childSegId][segId] == 0 )
        {
            Search(childSegId * -1, curLen + len[segId], destSeg, depth-1);
        }
        else if ( connect[childSegId][segId] == 1 )
        {
            Search(childSegId, curLen + len[segId], destSeg, depth-1);
        }
    }
    visited[segId] = 0;
}

void Solve ()
{
    int i, j;
    for (i = 3; i &lt;= n; i ++)
    {
        for (j = 1; j &lt;= n; j ++)
        {
            Search(j, 0, j, i);
//          不需要枚举另一端，因为s-&gt;e和e-&gt;s的效果是一样的
//          Search(-1*j, 0, -1*j, i);
        }
    }
    printf("%d\n", curMax);
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/5/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/3/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/03/24/branch-in-my-eye/">公司设立分部弊端之我见</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/03/18/log-practice/">日志规范实践</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/02/24/a-try-to-play-with-travis-ci/">小试Travis-Ci</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/01/31/typelist-and-abstract-fatory/">Typelist && Abstract Fatory</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/01/23/typelist-in-template-metaprogramming/">模板元编程中的Typelist</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/quxiao">@quxiao</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'quxiao',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Xavier -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'qxavier';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
