
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Xavier's Blog</title>
  <meta name="author" content="Xavier">

  
  <meta name="description" content="平时我就在想，我们这些程序员，或者说是写代码的，应该去怎样的企业呢？去怎样的企业，使我们能有长远的发展？去怎样的企业，让我们能为社会贡献的更多？最近自己都在找工作，我也不得不面对这样的问题。对我来说，期望值从高到低应该是这样一个顺序： 一流研究机构（微软亚洲研究院、Yahoo! 研究院、 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://quxiao.github.io/blog/page/4">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Xavier's Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Xavier's Blog</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:quxiao.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/09/21/for-programmers-should-go-a-little-bit-of-how-the-business-views/">对于程序员应该去怎样的企业的一点点看法</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-09-21T14:51:23+08:00" pubdate data-updated="true">Sep 21<span>st</span>, 2011</time>
        
           | <a href="/blog/2011/09/21/for-programmers-should-go-a-little-bit-of-how-the-business-views/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/09/21/for-programmers-should-go-a-little-bit-of-how-the-business-views/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>平时我就在想，我们这些程序员，或者说是写代码的，应该去怎样的企业呢？去怎样的企业，使我们能有长远的发展？去怎样的企业，让我们能为社会贡献的更多？最近自己都在找工作，我也不得不面对这样的问题。对我来说，期望值从高到低应该是这样一个顺序：</p>

<h4><strong>一流研究机构</strong>（微软亚洲研究院、Yahoo! 研究院、IBM研究院）</h4>

<p>创新，是改变世界、使得社会得以不断发展的一个重要的因素，而研究机构正是孕育创新摇篮。研究机构里面的研究成果，可能只是一个设想、一个原型，不一定能够立即投入到应用当中。不过一旦研究出点什么，则会对我们的生活有着本质的影响。想起前段时间在南京软件博览会上玩的Kinect，就让人不由的感受到了创新对于改变人们生活方式的力量。</p>

<p>在我的想象当中，一流研究机构里面员工的工作方式应该是：一群人在几乎没有压力的情况下，根据自己的兴趣方向，查阅大量文献资料，找到有意义的创新点，自己编码做出原型系统并不断改进，然后重复上述步骤。</p>

<p>能够在几乎无压力的情况下做自己感兴趣的事情，自己喜欢的事情就是自己的事业，这应该就是最理想的情况了。但是，一流的研究机构对于员工的要求也是及其严格的（这似乎已经大大超出程序员的职责了），你要有深厚的科研能力、扎实的数学功底、缜密的逻辑思维，而且还要有相当的编程能力，能同时具备这些素质的人，很少很少！</p>

<h4><strong>中大型互联网公司</strong>（Google、百度、腾讯、阿里巴巴、网易、淘宝）</h4>

<p>这个时代毕竟是Web的时代，Web已经是无处不在了，所以从事互联网行业还是很有前途的。互联网的主要用户是和我们一样，都是年轻人。互联网公司中的员工，绝大部分也是年轻人。年轻人嘛，都是希望自由、平等、不受拘束，所以公司的氛围一般都是比较轻松的，人与人之间的交流也比较平等、单纯。而且，由于互联网行业的特点，一旦有了较高的、稳定的用户量，公司将会有较快的发展速度，员工就能在这个过程中与公司一同成长，能够经历很多，也能学到很多。</p>

<p>其中，对于那些大型互联网公司，用户量庞大并且稳定，已经找到很好的盈利点，肯定是饿不死的。不过，公司里面的人员机构也会相对臃肿一些，员工在里面可能只会接触到其中的很小一块，不会一开始就了解公司系统的整体构架，但应该会做的比较深。</p>

<p>而那些还处在发展中阶段的中型互联网公司，刚刚起步，员工在里面能经历到公司发展的各个阶段，也能在一开始就了解公司系统的各个方面。不过，在这种公司冒的风险就要稍微大一点了，万一外部或者内部环境出了状况，公司一口气上不来，就。。。</p>

<h4><strong>国外著名软件公司</strong>（微软、IBM、Oracle）</h4>

<p>谁叫计算机是外国人发明出来的呢，外国（尤其是美国）在计算机这一块还是遥遥领先于其他国家的，他们经历了电脑从无到有、PC普及、以及目前互联网的时代。我想不管是理论上、技术上，还是整个的氛围，都比国内高不止一个档次。这些国外著名的软件公司，历史悠久，资金雄厚，技术方面更是不用说。因此，如果能进入这些公司，可以感受到国际一流的技术和氛围，也有机会能与全世界各国的人士交流，整个视野也会比较开阔。而且，这些公司绝大部分都会落户于北京、上海这样的中国一线城市，对于想在一线城市打拼的人来说应该是个不错的选择。</p>

<p>当然，正如前面说到的，公司一旦大了，就难免显得臃肿，每个员工在里面一开始都只负责其中的一小块。而且，其中有些公司，真正的核心技术还是在国外的总部进行研发的，中国的公司可能就负责一些周边的系统，有的甚至是处理一些服务性质的工作，如果是这样的话，那就没什么意思了。</p>

<h4><strong>大型非软件公司的IT部门</strong>（中兴、华为、移动、银行）</h4>

<p>有些大公司，不是纯粹的软件公司，有可能是做电信的或者金融，但其中的IT部门也会有很大的规模。在这些公司的话，工作就会集中在某一个行业里了，做的深的话就可以成为某一个行业的IT专家了，优点是可以凭经验吃饭，工作时间越长越有竞争力，缺点就是你只能局限在一个小圈子甚至几个同类公司了。里面有些公司，业务散得很大，需要大量的人，所以进去相对容易一些，比如中兴、华为。（不过至今未收到中兴的面试通知，好歹给我个保底啊！）另外一些公司，不需要大量的人力，想进去就困难的多了，比如中国移动或者一些银行。（上次在网上看了摩根斯坦利的技术笔试题，感觉对员工的英语、数学、逻辑以及技术的要求都非常高。）</p>

<h4><strong>创业公司</strong></h4>

<p>这两年在中国，创业的氛围还是挺浓的。我周围就有一些同学一毕业或者工作2、3年就去创业了，有的不时还诱惑我，希望我跟他们一起干。上次我还意外的去了家创业公司看了看，里面的老板是CMU毕业的博士，在国外工作了二十多年，然后回国创业。公司的技术氛围还不错，跟老板聊了聊，感觉人家还是挺有想法的。</p>

<p>在创业公司工作的话，几乎就是从零开始，好处很明显，如果公司起来了，你就是创始人之一啦！但是，在创业公司压力也很大，公司说不定随时都会倒掉。如果没有足够的拼劲和毅力的话，不要选择创业公司；如果没有自己的想法，只想完成别人给你的任务，也不要选择创业公司；如果自己技术不过关，那更不要选择创业公司。因为在创业公司，每一位员工都是要有贡献的，是容不得人吃闲饭的。</p>

<h4><strong>外包公司</strong>（南大富士通、东软）</h4>

<p>外包嘛，大家都懂得，就是一些公司把非核心技术方面的东西拿给这些公司来做。如果有固定的客户或者就是某个公司的“内包”的话，那就不愁没项目接，不然就要去到处拉项目了。做外包项目，基本上都是些大同小异的东西，最终只要按合同上写好的要求完成就可以了。在外包公司里面，我感觉技术方面学不到很多，不过工程方面的知识和经验倒还是可以学到不少的。</p>

<p>嗯，大概就是这些吧！本人能力有限，能想到的大概是这么多，肯定有许多考虑不周的地方，欢迎拍砖！</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/09/08/speaking-from-a-recent-job/">从最近找工作说起</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-09-08T15:26:25+08:00" pubdate data-updated="true">Sep 8<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/09/08/speaking-from-a-recent-job/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/09/08/speaking-from-a-recent-job/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>求职季开始了，大家都忙碌起来了，完善自己的简历，进行网申，复习专业知识，准备笔试和面试。这个过程，其实也是对自己整个大学生涯的回顾和总结。看看自己的简历，看看自己以前到底做过些什么，到底做过些什么有意义的事情，到底做过些什么没有任何人逼你、你却乐在其中、做完后很有成就感的事情。这些事情，对我来说，有，但不多。</p>

<p>还是来说说最近碰到的一些事情以及一些感悟吧。</p>

<p>写简历时，我发现一个很严重的问题：在研究生阶段，自己的能力没有得到什么提高，至少没有明显的提高。之前准备上研究生的时候，总是会憧憬着研究生阶段会有许多项目做，生活会很忙碌、很充实。可是没想到，原来研究生阶段大多都是自学成才！（我周围都是这样的，不代表所有情况）研究生阶段，说白了就是给导师打工，很可惜，导师一般情况下给你不会是实际的项目，而是让你些各种策划书，查阅论文，搜集资料。至于学术研究，大家都是自己搞自己的一部分，遇到问题基本上也没人可以讨论的，自己研究的东西导师可能也不是很了解。相比较而言，还是本科的时候更自在、更充实！但是，有些事情自己还是要肯定一下自己的。比如研究生阶段还是去做了POJ和USACO上面的题目，搞了个人的技术博客，仍然坚持关注业内的动态，去考了中级口译（虽然口试部分没通过 :( ），也还是算在不停折腾的，没有完全打酱油。</p>

<p>当然，我也不能说我选择上研究生是错误的，无论选哪一条路，只要走好了，前途都会很光明的。读研也是有很多好处的，例如没有工作那么辛苦，有一些自由的时间，可以做一些自己感兴趣的事情（当然，这里感兴趣的事情，是与专业相关的，不是玩游戏、看电视剧这些事情）。反正有利有弊吧，就看你怎么做了。</p>

<p>另外，最近在找工作时也发生了一件令人哭笑不得的事情。教研室一X同学看许多公司招聘职位的要求里面都需要熟悉Python，他从没学过Python，但居然在简历里面写上“熟悉Python”投给了应聘的公司。为了不露馅，这两天配置了一下Python环境，看了几页书，写出个“Hello，world”，他就表示自己已经熟悉Python了。。。你说你之前学过些什么，现在记不清了，复习一下，这还情有可原，但在简历里面写着熟练掌握的东西，自己居然从来没学过，这就有点太过分了。你看中国的教育把X同学折磨成什么样了，这简直就是应试的另一个极端体现。不是因为Python是一门简洁的语言，不是因为Python可以高效的解决平时开发中的种种问题，而是因为招聘单位要求熟悉Python，所以他才要学习Python，真是让人觉得可笑又可悲。</p>

<p>当然，我也相信，许多同学（包括我）都会或多或少的给简历加点“水分”，添点色彩，谁又能完全免俗呢？但是，我希望能在这个复杂的世界里面能尽量保持一份单纯，怀着单纯的喜爱做出一些觉得对自己、对别人有意义的事情，并且希望能把这个世界变得更好。世界的复杂我们也许无法改变，但我们能够改变自己，或者说是改善自己，这是在我们力所能及的范围之内的。我们从小学、中学、大学、或者再到研究生，难道得到的仅仅是一个个学历，一张张纸吗？绝对不应该是这样！学习的目的之一，应该就是让我们有这样的理想、这样的动力，让我们在这纷繁的世界中保持相对的单纯，而不是在这个世界随波逐流，与这个世界“同流合污”。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/08/16/hadoop_easy_test/">Hadoop极精简运行实验</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-08-16T14:18:33+08:00" pubdate data-updated="true">Aug 16<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/08/16/hadoop_easy_test/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/08/16/hadoop_easy_test/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>出于对海量数据处理的兴趣以及毕设实验的要求，最近空闲时间小搞了一下Hadoop。对Hadoop不了解的同学，可以看<a href="http://hadoop.apache.org/">这里</a>。简单的说，它是一个利用MapReduce编程模型进行分布式大规模数据处理的框架。在Hadoop中，数据都表示为键/值对的形式，以便用MapReduce进行处理。MapReduce的思想十分简单，数据的处理过程分为两个阶段：map和reduce。map过程是将value（源数据）映射到不同的key中，这样所有数据就变成了key/value的集合，一个key会对应多个value；而在reduce阶段，则将每一个key的value集合进行处理，最后也同样得到key/value的集合，但这里一个key对应的一个value（计算结果）。</p>

<p>对于使用Hadoop的人来说，其实我们只需编写map和reduce函数，以及一个驱动程序即可，至于Hadoop是如何将多个value统一到一个key中，并且对这些value进行分组、排序，我们可以不考虑（只是暂时的）。由于手边没有“海量”数据，我只好自己造了。简单起见，我直接以键值对的形式生成了数据，而场景就是找到每个key的最大value。</p>

<p>我们首先来看map函数：</p>

<pre><code>package main;

import java.io.IOException;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Mapper.Context;

/*
* map function
* the 4 class arguments of Mapper mean: input key, input value, output key, output value
*/
public class FindMaxInKeyMapper extends Mapper&lt;LongWritable, Text, IntWritable, IntWritable&gt;
{

    public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException
    {
        String line = value.toString();
        String[] results = line.split(" ");
        int id, num;
        try
        {
            id = Integer.parseInt(results[0]);
            num = Integer.parseInt(results[1]);
        }
        catch (Exception ex)
        {
            return;
        }
        // add key/value
        context.write(new IntWritable(id), new IntWritable(num));
    }
}
</code></pre>

<p>map阶段是数据的整理阶段，基类Mapper中的类型参数分别表示：输入的key、value类型，以及输出的key、value类型。注意，这里输出的key/value与MapReduce中的概念是一致的，而输入的key/value则不是，一般来说，输入的key表示输入数据的偏移量，而输入的value表示数据本身。所以，map阶段的主要任务就是把输入的value（源数据）表示成key/value的形式，供下一步的reduce使用。我们这个例子中，只需将表示一行的String分别分解成两个int就可以了。</p>

<p>好，再来看看reduce函数：</p>

<pre><code>package main;

import java.io.IOException;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.Reducer.Context;

public class FindMaxInKeyReducer  extends Reducer&lt;IntWritable, IntWritable, IntWritable, IntWritable&gt;
{
    /*
     * reduce function
     * find the max value in values (in the same key)
     */
    public void reduce(IntWritable key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException
    {
        int maxValue = Integer.MIN_VALUE;
        for (IntWritable value: values)
        {
            maxValue = Math.max(maxValue, value.get());
        }
        context.write(key, new IntWritable(maxValue));
    }
}
</code></pre>

<p>reduce阶段就是数据进行实质处理的阶段了，它的输入源于map阶段，是一个key和一个value的集合，它的输出就是一个key/value对。输入输出的key/value类型可以各不相同，只要map输出的key/value类型和reduce输入的一样就可以了。在我们的例子里面，只要在values里面找到一个最大的，然后以同样的key和那个最大的value最为输出、放入context即可。</p>

<p>最后，写一个驱动程序（不是设备的驱动程序，你懂的）：</p>

<pre><code>package main;

import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;

public class FindMaxInKey { 

    public static void main(String[] args) throws Exception{
        if ( args.length != 2 )
        {
            System.err.println("Usage: FindMaxInKey &lt;input path&gt; &lt;output path&gt;");
            System.exit(-1);
        }

        Job job = new Job();
        job.setJarByClass(FindMaxInKey.class);

        FileInputFormat.addInputPath(job, new Path(args[0]));
        FileOutputFormat.setOutputPath(job, new Path(args[1]));

        job.setMapperClass(FindMaxInKeyMapper.class);
        job.setReducerClass(FindMaxInKeyReducer.class);

        job.setOutputKeyClass(IntWritable.class);
        job.setOutputValueClass(IntWritable.class);

        System.out.println("start working");
        System.exit(job.waitForCompletion(true) ? 0: 1);
    }

}
</code></pre>

<p>驱动程序的工作也很简单，设置一下Map类、Reduce类、数据输入输出路径，基本上就可以了。好，下面，跑起来！</p>

<p>如果在配置中采用默认设置，Hadoop底层的文件系统就是本地操作系统的文件系统。不过，一般都要设置成HDFS分布式文件系统的。（肯定啊，否则Hadoop有个什么意义）将工程打成jar包，然后敲入命令：</p>

<blockquote><p>quxiao@ubuntu1:~/hadoop/bin$ ./hadoop jar /home/quxiao/workspace/HadoopTest/HadoopTest.jar main.FindMaxInKey /user/quxiao/data.in /user/quxiao/outputdata</p></blockquote>

<p>就可以看到命令行中提示map和reduce的完成百分比，在Hadoop自带的监控系统可以更直观的看到运行的信息。</p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/08/Screenshot-2.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/08/Screenshot-2-1024x573.png" alt="" /></a></p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/08/Screenshot-3.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/08/Screenshot-3-1024x573.png" alt="" /></a></p>

<p>运行之后，程序的输出是这种形式：</p>

<blockquote><pre><code>0 2147435993
1 2147464484
2 2147479158
3 2147458512
4 2147389924
5 2147416503
6 2147378427
7 2147478518
8 2147433586
9 2147435229
10    2147381593
11    2147463851
12    2147454928
13    2147462197
14    2147480411
15    2147481870
16    2147469297
17    2147435232
18    2147439681
19    2147437661
</code></pre></blockquote>

<p>好！这个极精简实验就算是运行成功了。初步来看，用Hadoop做数据分析还是挺简单的，你不用担心数据的分组、排序、存储，以及许多分布式相关的细节，只要写好map和reduce函数即可。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/25/deap/">双端堆</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-07-25T14:17:06+08:00" pubdate data-updated="true">Jul 25<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/07/25/deap/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/07/25/deap/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>之前有同学问我，怎么在一个集合中高效的找到最大以及最小的元素？（注意，不是总是找最大元素，或者总是找最小元素，而是类似随机的查找最大以及最小元素。）一开始有几种想法：</p>

<p>朴素的想法</p>

<p>把集合遍历一遍，就可以知道最大或者最小元素了，查找复杂度是O(N)，查找并删除的复杂度也是O(N)。</p>

<p>堆结构</p>

<p>用两个堆，一个最大堆，一个最小堆，两个堆各存一份数据。查找最大元素，就在最大堆里面找；查找最小元素，就在最小堆里面找，他们的查找时间复杂度是O(1)，查找并删除的复杂度是O(logN)。但是，怎么“同步”这两个堆呢？即，在最大堆里面删除最小的元素，在最小堆里面删除最大的元素。我们知道的只是：最小（大）元素在最大（小）堆的叶子上。怎么判断节点是叶子呢？下标×2 > size就是叶子，但是叶子上面的元素又不是排序的，查找的复杂度只能是O(N)。所以，这种想法的复杂度还是O(N)。</p>

<p>双端堆（灯，等灯等灯！）</p>

<p>突然想到小倩同学之前好像说过一个叫双端堆的数据结构，可以同时高效的查找最大最小元素。问了下小倩，然后又发现原来最近看的《<a href="http://book.douban.com/subject/3576025/">数据结构基础</a>》上面，就有相关的内容，只不过里面不叫双端堆，而是叫做对称最小-最大堆。（我个人感觉这两种名称讲的就是同一个数据结构）它就可以在O(1)的复杂度的情况下，找到最小（大）元素；O(logN)的情况下找到并删除最小（大）元素。</p>

<p><strong>双端堆的特点</strong></p>

<p>双端堆是一棵满二叉树，最顶端的根是一个虚根，不存放数据。定义element(N)为节点N的所有子孙节点（不包括N本身）的集合，N的左孩子left(N)（如果有的话）是element(N)中最小的元素，右孩子right(N)（如果有的话）是element(N)中最大的元素。</p>

<p>当以下条件成立时，它才是双端堆：</p>

<ul>
<li><p>P1：每个节点的元素小于等于它的右兄弟（如果有）</p></li>
<li><p>P2：对于每个有祖父的节点N，其祖父节点的左孩子小于等于N</p></li>
<li><p>P3：对于每个有祖父的节点N，其祖父节点的右孩子大于等于N</p></li>
</ul>


<p>比如下图就是一个双端堆</p>

<p><img src="http://quxiao.github.io/images/2011-07-25-deap/image_thumb20.png" alt="image" /></p>

<p>下面我们看看实现</p>

<p>既然是一个满二叉树，那么就可以像堆一样有一个数组来表示，下标为n的节点的左右孩子的下标分别为2×n和2×n+1。</p>

<p><strong>插入操作</strong></p>

<p>现将该元素放在树的最后，看有没有满足性质P1，若违反，交换两节点的内容。再看是否满足上面讲的性质P2或者P3，如果满足，就将元素放在当前位置；若没有：</p>

<ul>
<li><p>违反P2，将当前节点与其祖父的左孩子交换，祖父的左孩子变成当前节点；</p></li>
<li><p>违反P3，将当前节点与其祖父的右孩子交换，祖父的右孩子变成当前节点。</p></li>
</ul>


<p>重复进行判断，直至找到合适的位置。</p>

<p>假设插入2，过程如下图：</p>

<p><img src="http://quxiao.github.io/images/2011-07-25-deap/image_thumb21.png" alt="image" />
=>
<img src="http://quxiao.github.io/images/2011-07-25-deap/image_thumb22.png" alt="image" />
=>
<img src="http://quxiao.github.io/images/2011-07-25-deap/image_thumb23.png" alt="image" /></p>

<p>代码如下:</p>

<div>
  <pre><code class='java'>public void insert (T data) throws Exception
    {
        int curIdx = ++ size;
        if ( size &gt;= HEAP_MAX_SIZE )
            throw new Exception();
        int grandpa;
        int parentMin, parentMax;       //爷爷的左右孩子
        while (true)
        {
            //是否有更大的左兄弟
            if ( (curIdx &amp; 1) == 1 &amp;&amp; data.compareTo(heap[curIdx-1]) &lt; 0 )
            {
                heap[curIdx] = heap[curIdx-1];
                -- curIdx;
            }

            grandpa = curIdx &gt;&gt; 2;
            if ( grandpa == 0 )
                break;
            parentMin = grandpa &lt;&lt; 1;
            parentMax = parentMin + 1;
            if ( heap[parentMin].compareTo(data) &gt; 0 )
            {
                heap[curIdx] = heap[parentMin];
                curIdx = parentMin;
            }
            else if ( heap[parentMax].compareTo(data) &lt; 0 )
            {
                heap[curIdx] = heap[parentMax];
                curIdx = parentMax;
            }
            else
                break;
        }
        heap[curIdx] = data;
    }</code></pre>
</div>


<p><strong>删除操作</strong></p>

<p>这里面的删除操作应该是指找到并删除最小（大）元素，找到很容易，最小元素是根的左孩子，最大元素是根的右孩子。但是，删除之后怎么调整以满足双端堆的特性呢？我们以删除最小元素为例，算法如下：</p>

<p>我们将树的最后一个元素暂时放在删除元素的位置，判断两个条件：</p>

<p>是否满足P1，不满足则交换两元素</p>

<p>与其左孩子、以及右兄弟节点的左孩子（如果有的话）比较，是否是最小的，不是则与最小的节点交换。（其左孩子和右兄弟的左孩子是两个次小的节点）</p>

<p>重复以上判断，直至满足这两个条件。</p>

<p>如果删除4的话，过程如下图：</p>

<p><img src="http://quxiao.github.io/images/2011-07-25-deap/image_thumb24.png" alt="image" />
=>
<img src="http://quxiao.github.io/images/2011-07-25-deap/image_thumb25.png" alt="image" />
=>
<img src="http://quxiao.github.io/images/2011-07-25-deap/image_thumb26.png" alt="image" />
=>
<img src="http://quxiao.github.io/images/2011-07-25-deap/image_thumb27.png" alt="image" />
=>
<img src="http://quxiao.github.io/images/2011-07-25-deap/image_thumb28.png" alt="image" /></p>

<p>代码如下：</p>

<div>
  <pre><code class='java'>public T deleteMin () throws Exception
    {
        if ( size &lt; 2 )
            throw new Exception();
        if ( size == 2 )
            return heap[size --];

        T tmp;
        int minChildIdx;
        T data = heap[size --];
        int curIdx = 2;
        T ret = heap[curIdx];
        while ( true )
        {
            if ( (curIdx &amp; 1) == 0 &amp;&amp; curIdx + 1 &lt;= size &amp;&amp; data.compareTo(heap[curIdx+1]) &gt; 0 )
            {
                tmp = heap[curIdx+1];
                heap[curIdx+1] = data;
                data = tmp;
            }
            minChildIdx = curIdx &lt;&lt; 1;
            if ( minChildIdx &gt; size )
                break;
            if ( ((curIdx + 1) &lt;&lt; 1) &lt;= size &amp;&amp; heap[minChildIdx].compareTo(heap[(curIdx+1)&lt;&lt;1]) &gt; 0 )
                minChildIdx = (curIdx + 1) &lt;&lt; 1;
            if ( data.compareTo(heap[minChildIdx]) &gt; 0 )
            {
                heap[curIdx] = heap[minChildIdx];
                curIdx = minChildIdx;
            }
            else
                break;
        }
        heap[curIdx] = data;
        return ret;
    }</code></pre>
</div>


<p>所有代码可以在<a href="http://code.google.com/p/quxiao-source-code/source/browse/#svn%2Ftrunk%2Fdata_structure%2FSMMH%2Fsrc">这里</a>看到。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/21/avl_tree_implimentation/">AVL树初步实现</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-07-21T21:12:20+08:00" pubdate data-updated="true">Jul 21<span>st</span>, 2011</time>
        
           | <a href="/blog/2011/07/21/avl_tree_implimentation/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/07/21/avl_tree_implimentation/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这两天复习数据结构，看到AVL树这一部分，之前这部分一直处于“纸上谈兵”的阶段，表示有些遗憾。趁着最近比较闲，把它实现一下！</p>

<p>还是先讲一下AVL树的基本概念吧。其实，AVL树就是二叉树，与普通二叉树不同的是，它能通过某种操作（“旋转”）使得树保持几乎平衡，这里就是指左子树和右子树的树高差的绝对值&lt;=1。当二叉树是平衡的情况下，在树上的搜索效率就会提高。极端情况下，能从O(N)降到O(logN)。</p>

<p>OK，那么又有哪几种不平衡的情况呢？我们来看一下下面几种情况：</p>

<p>右子树的右子树太“深”</p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/07/image.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/07/image_thumb.png" alt="image" /></a></p>

<p>树往一边倾斜，这是一种常见的不平衡状态。比如把一个已排序的数据插入二叉树就是这种情况。遇到这种情况，如果可以把k2“提”起来就好了。很简单，我们可以把k2作为树根，k1做k2的左孩子，再把B当作k1的右子树。旋转之后可以得到：</p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/07/image1.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/07/image_thumb1.png" alt="image" /></a></p>

<p>这样，树又基本平衡了。左子树的左子树太深的情况可依此类推。这两种情况成为单旋转。</p>

<p>还有一种情况，右子树的左子树太“深”</p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/07/image2.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/07/image_thumb2.png" alt="image" /></a></p>

<p>这样就k2不好“提”了，因为旋转之后，B子树的树高没有改变。把树描述的更加详细一些：</p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/07/image3.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/07/image_thumb3.png" alt="image" /></a> => <a href="http://www.qxavier.me/wp-content/uploads/2011/07/image4.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/07/image_thumb4.png" alt="image" /></a></p>

<p>我们的目标是把k3以及BC放的高一些，以降低整体树高。因为k1&lt;=k3&lt;=k2，那可否让k3来做树根呢？k3做了树根，k1和k2是其左右孩子，AD子树可以不变，B可以作为k1右子树，C可以作为k2左子树，这样就搞定了！</p>

<p>同样，左子树的右子树太深的情况也是类似。这两种情况成为双旋转。</p>

<p>好，用代码实现这些操作！</p>

<p>根据单旋转的图例，两步操作就可以完成：</p>

<ol>
<li><p> k2的左指针指向k1</p></li>
<li><p> k1的右指针指向B</p></li>
</ol>


<p>代码实现就是这样：</p>

<pre><code>AVLTree* singleRotateWithRight(AVLTree* pNode)
{
    if ( pNode == NULL || pNode-&gt;right == NULL )
        return NULL;
    AVLTree* rightNode = pNode-&gt;right;
    pNode-&gt;right = rightNode-&gt;left;
    rightNode-&gt;left = pNode;

    pNode-&gt;height = max(getHeight(pNode-&gt;left), getHeight(pNode-&gt;right)) + 1;
    rightNode-&gt;height = max(getHeight(rightNode-&gt;left), getHeight(rightNode-&gt;right)) + 1;

    return rightNode;
}
</code></pre>

<p>再看双旋转的实现，很奇妙的是，一个双旋转可以用两个但旋转来代替！</p>

<p><a href="http://www.qxavier.me/wp-content/uploads/2011/07/image5.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/07/image_thumb5.png" alt="image" /></a>=><a href="http://www.qxavier.me/wp-content/uploads/2011/07/image6.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/07/image_thumb6.png" alt="image" /></a> =><a href="http://www.qxavier.me/wp-content/uploads/2011/07/image7.png"><img src="http://www.qxavier.me/wp-content/uploads/2011/07/image_thumb7.png" alt="image" /></a></p>

<p>实现起来相当简单：</p>

<pre><code>AVLTree* doubleRotateWithRight (AVLTree* pNode)
{
    pNode-&gt;right = singleRotateWithLeft(pNode-&gt;right);
    return singleRotateWithRight(pNode);
}
</code></pre>

<p>插入操作怎么实现呢？其实就是在普通二叉树的插入操作之后，加入判断是否不平衡，若不平衡，判断是哪种情况，进行相应旋转操作。</p>

<pre><code>AVLTree* insert(int data, AVLTree* pNode)
{
    if ( pNode == NULL )
    {
        pNode = new AVLTree();
        pNode-&gt;data = data;
        pNode-&gt;height = 0;
        pNode-&gt;left = pNode-&gt;right = NULL;
    }
    else if ( data &lt; pNode-&gt;data )
    {
        pNode-&gt;left = insert(data, pNode-&gt;left);
        if ( getHeight(pNode-&gt;left) - getHeight(pNode-&gt;right) == 2 )
        {
            if ( data &lt; pNode-&gt;left-&gt;data )
            {
                pNode = singleRotateWithLeft(pNode);
            }
            else
            {
                pNode = doubleRotateWithLeft(pNode);
            }
        }
    }
    else if ( data &gt; pNode-&gt;data )
    {
        pNode-&gt;right = insert(data, pNode-&gt;right);
        if ( getHeight(pNode-&gt;right) - getHeight(pNode-&gt;left) == 2 )
        {
            if ( data &gt; pNode-&gt;right-&gt;data )
            {
                pNode = singleRotateWithRight(pNode);
            }
            else
            {
                pNode = doubleRotateWithRight(pNode);
            }
        }
    }

    return pNode;
}
</code></pre>

<p>好吧，先写这么多，性能对比以后再写。全部实现代码可以在<a href="http://code.google.com/p/quxiao-source-code/source/browse/#svn%2Ftrunk%2Fdata_structure%2FAVLTreeCPP%2FAVLTreeCPP">这里</a>看到。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/15/usaco-section-4-1-cryptcowgraphy/">USACO Section 4.1 Cryptcowgraphy</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-07-15T00:00:54+08:00" pubdate data-updated="true">Jul 15<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/07/15/usaco-section-4-1-cryptcowgraphy/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/07/15/usaco-section-4-1-cryptcowgraphy/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>题目大意：</p>

<p>一种字符串加密算法，即在原有字符串的任意位置插入C、O、W，C的下标 &lt; O的下标 &lt; W的下标，将C、O之间和O、W之间子串交换，得到新的字符串。给你一个字符串，问其是否是对字符串Begin the Escape execution at the Break of Dawn经过多次加密过后的字符串。</p>

<p>我的思路：</p>

<p>首先，原字符串中并没有COW三个字母，所以不用判断COW是属于原先的字符还是加密时加上的字符，这样简单很多。另外，对于已加密的字符串，只要找到任意一组COW，交换CO和OW之间的子串，再把COW删掉，得到的字符串就是可能的一种原字符串，再这样递归下去，直到不可能的情况或者字符串变为Begin the Escape execution at the Break of Dawn。</p>

<p>在搜索时，有几种减枝可以排除目前的字符串：</p>

<ul>
<li><p>如果目前字符串的长度不等于原串长度+3×k，排除。（其实只需在开始时判断一次即可）</p></li>
<li><p>如果目前字符串中COW三个字母的数目不相等，排除。（也可只判断一次）</p></li>
<li><p>如果任意COW字符之间的子串，没有出现在原串中，排除。（这个减枝很重要，但是没想到，不应该啊）</p></li>
<li><p>字符串中，所有出现COW的地方，C应该排在第一个，W应该排在最后一个。否则，无法还原成原字符串。</p></li>
<li><p>用hash来判断目前字符串之前有没有出现过。（hash表的大小选择很关键，选的太大，可能会超时，选的太小，可能会WA）</p></li>
</ul>


<p>另外，枚举COW时的搜索方式也很重要。如果每一层都会从i到len，像这样：</p>

<pre><code>    for (i = 0; i &lt; l; i ++)
    {
        if ( str[i] != 'C' )
            continue;
        for (j = i + 1; j &lt; l; j ++)
        {
            if ( str[j] != 'O' )
                continue;
            for (k = j + 1; k &lt; l; k ++)
            {
                if ( str[k] != 'W' )
                    continue;
                if ( CheckStr( RestoreString(str, i, j, k)) )
                    return true;
            }
        }
    }
</code></pre>

<p>很容易就超时了。</p>

<p>但是，如果先把所有COW的下标先记下来，再在每一层枚举它们的下标，像这样：</p>

<pre><code>    for (i = 0; i &lt; cNum; i ++)
    {
        for (j = 0; j &lt; oNum; j ++)
        {
            for (k = 0; k &lt; wNum; k ++)
            {
                if ( cIdx[i] &lt; oIdx[j] &amp;&amp; oIdx[j] &lt; wIdx[k] )
                {
                    if ( CheckStr( RestoreString(str, cIdx[i], oIdx[j], wIdx[k])) )
                        return true;
                }
            }
        }
    }
</code></pre>

<p>就会快很多。</p>

<p>好了，废话不多说，直接上代码：</p>

<pre><code>unsigned int elf_hash(string str)
{
    unsigned long h = 0, g, i, l;
    l = str.length();
    for (i = 0; i &lt; l; i ++)
    {
        h = (h &lt;&lt; 4) + str[i];
        if (g = h &amp; 0xf0000000l)
            h ^= g &gt;&gt; 24;
        h &amp;= ~g;
    }
    return h % HASH_NUM;
}

//COW的数目是否相等，以及数目是多少
//其实跟CheckStr中的判断有重复，还可以优化！
int CheckCOWNum (string str)
{
    int i, l;
    int nC, nO, nW;
    nC= nO = nW = 0;
    l = str.length();

    for (i = 0; i &lt; l; i ++)
    {
        if ( str[i] == 'C' )
            ++ nC;
        else if ( str[i] == 'O' )
        {
            ++ nO;
        }
        else if ( str[i] == 'W' )
        {
            ++ nW;
        }
    }
    if ( nC == nO &amp;&amp; nO == nW )
        return nC;
    else
        return -1;
}

//还原加密的字符串
//idx1 &lt; idx2 &lt; idx3
string RestoreString (string now, int idx1, int idx2, int idx3)
{
    string pre = "";
    int i, l;
    l = now.length();
    pre = now.substr(0, idx1);
    pre += now.substr(idx2+1, idx3-idx2-1);
    pre += now.substr(idx1+1, idx2-idx1-1);
    pre += now.substr(idx3+1, l-idx3-1);

    return pre;
}

bool CheckBetweenCOW (string str)
{
    int lastIdx;
    int i, l;
    lastIdx = -1;
    l = str.length();
    for (i = 0; i &lt; l; i ++)
    {
        if ( str[i] == 'C' || str[i] == 'O' || str[i] == 'W' )
        {
            if ( finalStr.find(str.substr(lastIdx + 1, i - lastIdx - 1)) == string::npos )
            {
                return false;
            }
            lastIdx = i;
        }
    }
    return true;
}

bool CheckStr (string str)
{
    if ( str == finalStr )
        return true;

    int hash;
    hash = elf_hash(str);
    if ( hashVisited[hash] )
        return false;
    hashVisited[hash] = true;

    int i, j, k, l;
    int cNum, oNum, wNum, allNum;
    int cIdx[NUM], oIdx[NUM], wIdx[NUM], allIdx[NUM];
    cNum = oNum = wNum = allNum = 0;
    l = str.length();

    //记录C O W的下标
    allIdx[allNum++] = -1;
    for (i = 0; i &lt; l; i ++)
    {
        if ( str[i] == 'C' )
        {
            cIdx[cNum++] = i;
            allIdx[allNum++] = i;
        }
        else if ( str[i] == 'O' )
        {
            oIdx[oNum++] = i;
            allIdx[allNum++] = i;
        }
        else if ( str[i] == 'W' )
        {
            wIdx[wNum++] = i;
            allIdx[allNum++] = i;
        }
    }
    if ( allIdx[allNum-1] != l - 1 )
        allIdx[allNum++] = l;

    //所有出现COW的地方，C应该排在第一个，W应该排在最后一个。否则，无法还原成原字符串
    if ( cNum )
    {
        if ( cIdx[0] &gt; oIdx[0] || cIdx[0] &gt; wIdx[0] )
            return false;
        if ( wIdx[wNum-1] &lt; cIdx[cNum-1] || wIdx[wNum-1] &lt; oIdx[oNum-1] )
            return false;
    }

    //任意COW之间的子串都应该在原串中出现过
    for (i = 0; i &lt; allNum-1; i ++)
    {
        if ( finalStr.find(str.substr(allIdx[i]+1, allIdx[i+1]-allIdx[i]-1)) == string::npos )
            return false;
    }

    for (i = 0; i &lt; cNum; i ++)
    {
        for (j = 0; j &lt; oNum; j ++)
        {
            for (k = 0; k &lt; wNum; k ++)
            {
                if ( cIdx[i] &lt; oIdx[j] &amp;&amp; oIdx[j] &lt; wIdx[k] )
                {
                    if ( CheckStr( RestoreString(str, cIdx[i], oIdx[j], wIdx[k])) )
                        return true;
                }
            }
        }
    }

    //这样就会很慢。。。
    //  for (i = 0; i &lt; l; i ++)
    //  {
    //      if ( str[i] != 'C' )
    //          continue;
    //      for (j = i + 1; j &lt; l; j ++)
    //      {
    //          if ( str[j] != 'O' )
    //              continue;
    //          for (k = j + 1; k &lt; l; k ++)
    //          {
    //              if ( str[k] != 'W' )
    //                  continue;
    //              if ( CheckStr( RestoreString(str, i, j, k)) )
    //                  return true;
    //          }
    //      }
    //  }

    return false;
}

void Solve ()
{
    if ( (str.length() - finalStr.length()) % 3 != 0 )
    {
        printf("0 0\n");
        return;
    }

    int nCOW = CheckCOWNum(str);
    if ( nCOW == -1 || !CheckStr(str) )
    {
        printf("0 0\n");
        return;
    }
    printf("1 %d\n", nCOW);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/05/usaco-section-4-1-fence-loops/">USACO Section 4.1 Fence Loops</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-07-05T21:56:12+08:00" pubdate data-updated="true">Jul 5<span>th</span>, 2011</time>
        
           | <a href="/blog/2011/07/05/usaco-section-4-1-fence-loops/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/07/05/usaco-section-4-1-fence-loops/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>题目大意：</p>

<p>有N个栏杆，告诉你它们的长度以及它们各自的连接情况，求出围成的最短的封闭空间的周长。其中，1 &lt;= N &lt;= 100，栏杆长度Ls，1 &lt;= Ls &lt;= 255，每个栏杆至多与另外8跟栏杆相连。</p>

<p>思路：</p>

<p>就是在图中找最小环。因为N（即边数）最大为100，即使通过枚举每个点进行搜索，复杂度也不过为100×100，可以采用搜索。枚举每个栏杆的一端顶点，如果搜索到这根栏杆的另一端顶点，那么就意味着找到环了，更新答案。</p>

<p>这题思路倒很简单，但是由于输入是以边为中心的，所以实现起来稍稍有点困难。我将每个栏杆的两个顶点定义为s端和e端，如果从某栏杆a的s端出发，那么枚举与a的e端相连的栏杆b，再判断是b的哪一端连接着a，枚举b的另一端，以此类推。</p>

<p>还有一些减枝和优化，比如：</p>

<ol>
<li><p> 收到<a href="http://www.qxavier.me/2011/07/01/usaco-section-4-1-fence-rails/">上一题</a>的启发，可以限定搜索深度，因为组成环的边数少，周长小的概率就比较大。</p></li>
<li><p> 当前的长度和大于等于目前的答案，退出。</p></li>
<li><p> 当前栏杆之前访问过，退出。</p></li>
<li><p> 只需枚举栏杆的一端即可，因为s->e和e->s的效果是一样的。</p></li>
</ol>


<p>看了USACO的官方分析，貌似处理的比较复杂，先把输入转化成标准的图，再对于每一条边，先删除它，然后用Dijkstras算法求最短路。这种方案相交于我的思路，没有太多优越性，但是编码的复杂度却也高。-_&ndash;</p>

<p>关键代码如下：</p>

<pre><code>const int N = 101;

int n;
int len[N];
vector&lt;int&gt; childSeg[N][2];     //[0] s end; [1] e end
short int connect[N][N];        //connect[a][b] = 0/1 means the s/e end of a connects with seg b
int curMax = 1&lt;&lt;20;
int visited[N];

/*
seg为负，表示当前节点为seg的s端
seg为正，表示当前节点为seg的e端
*/
void Search(int seg/*negtive s end; positive e end*/, int curLen, int destSeg, int depth)
{
    if ( seg == destSeg &amp;&amp; curLen != 0)
    {
        if ( curLen &lt; curMax )
            curMax = curLen;
        return;
    }
    if ( !depth )
        return;
    if ( curLen &gt;= curMax )
        return;

    int segId = abs(seg);
    if ( visited[segId] )
        return;
    visited[segId] = 1;
    int childSegId;
    //whichEnd, segId的另一端
    int whichEnd = 0;
    if ( seg &lt; 0 )
        whichEnd = 1;
    int i;
    for (i = 0; i &lt; childSeg[segId][whichEnd].size(); i ++)
    {
        childSegId = childSeg[segId][whichEnd][i];
        //从childSegId的另一端继续搜索
        if ( connect[childSegId][segId] == 0 )
        {
            Search(childSegId * -1, curLen + len[segId], destSeg, depth-1);
        }
        else if ( connect[childSegId][segId] == 1 )
        {
            Search(childSegId, curLen + len[segId], destSeg, depth-1);
        }
    }
    visited[segId] = 0;
}

void Solve ()
{
    int i, j;
    for (i = 3; i &lt;= n; i ++)
    {
        for (j = 1; j &lt;= n; j ++)
        {
            Search(j, 0, j, i);
//          不需要枚举另一端，因为s-&gt;e和e-&gt;s的效果是一样的
//          Search(-1*j, 0, -1*j, i);
        }
    }
    printf("%d\n", curMax);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/01/usaco-section-4-1-fence-rails/">USACO Section 4.1 Fence Rails</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-07-01T14:01:32+08:00" pubdate data-updated="true">Jul 1<span>st</span>, 2011</time>
        
           | <a href="/blog/2011/07/01/usaco-section-4-1-fence-rails/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/07/01/usaco-section-4-1-fence-rails/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>题目大意：</p>

<p>给你N(1 &lt;= N &lt;= 50)段长度不一的木材，另外有R(1 &lt;= R &lt;= 1023)条栏杆需要修复，1 &lt;= ri &lt;= 128。问以这些木材为原材料，能够做出最多多少块栏杆？（做出的栏杆需要是完整的，不能拼接）</p>

<p>思路：</p>

<p>这是一道背包问题，不过，这是高维背包。是把R个栏杆放入N段木材中，传统背包的DP解法在这里貌似就无能为力了，看了hint才知道，原来要用到DFSID算法，也就是限制搜索深度的DFS。是一种类似BFS的求解过程，但是却用DFS来实现的算法。简单的说，每次枚举搜索深度，进行DFS，如果未得到解，则继续增加（减少）搜索深度，直至找到解。</p>

<p>搜索的过程中，有一些重要的减枝：</p>

<ol>
<li><p> <strong>如果可以组成k块栏杆，那么最小的前k块栏杆一定是其中的一个解。</strong>因为就算存在不连续的解，我们也可以将较大的栏杆替换成较小的栏杆，最终转化为最小的k块栏杆。</p></li>
<li><p> 根据R和ri ，可以看出栏杆的长度有很多都是<strong>重复</strong>的。将木材和栏杆排序，搜索时记录下当前的栏杆是选择哪块木材。搜索到当前栏杆i时，如果发现与上一个栏杆i+1的长度相同，则我们可以从i+1块栏杆所选择的那块木材开始搜。</p></li>
<li><p> 假设前k块栏杆是题目的解，那么在这种情况下最大浪费掉的木材maxWaste就是sumBoard – sumRail[k]。在搜索过程中，如果发现某块木材的剩余量比最小的栏杆都小，就可以把他计入curWaste，如果发现curWaste > maxWaste，那么肯定无解。</p></li>
<li><p> 我们还可以将R的范围减小，如果发现sumRail[k] &lt;= sumBoard并且sumRail[k+1] > sumBoard，那么我们可以将R减小到k。</p></li>
</ol>


<p>嗯，差不多就是这些。还有一个减枝，就是如果发现栏杆长度比最大的木材还要长的话，那在输入的时候就略去它（貌似减枝效果不明显-_-）。我们从（经过优化过的）R开始搜索，假设前k个栏杆就是解，对于每个栏杆，枚举木材，基本上就是这么个思路。做完这题的最大感受就是：要善于挖掘题目中的潜在信息。根据R和ri的关系，得知栏杆有许多重复的情况，以及如何推导出如果k为解，则前k个栏杆肯定能构成解，这就是真正的分析问题的能力了！</p>

<p>以下是关键代码：</p>

<pre><code>bool Search (int rIndex)
{
    if ( rIndex &lt; 0 )
        return true;
    int bound = 0;
    //如果当前rail和上一个rail的长度相同，则从上一个rail选的board开始搜索
    if ( rIndex &lt; r - 1 &amp;&amp; rail[rIndex] == rail[rIndex+1] )
        bound = railSelect[rIndex+1];
    int i;
    bool ret = false;

    for (i = bound; i &lt; n; i ++)
    {
        if ( board[i] &gt;= rail[rIndex] )
        {
            board[i] -= rail[rIndex];
            railSelect[rIndex] = i;
            if ( board[i] &lt; rail[0] )
            {
                curWaste += board[i];
                //如果当前浪费的board大于最大允许的浪费量，则不选这个board
                if ( curWaste &gt; maxWaste )
                {
                    curWaste -= board[i];
                    board[i] += rail[rIndex];
                    railSelect[i] = -1;
                    continue;
                }
            }
            ret = Search(rIndex - 1);
            //恢复之前状态，顺序很重要！
            if ( board[i] &lt; rail[0] )
                curWaste -= board[i];
            board[i] += rail[rIndex];
            railSelect[rIndex] = -1;
            if ( ret )
                return true;
        }
    }

    return false;
}

void Solve ()
{
    int i;
    memset(railSelect, -1, sizeof(railSelect));
    sort(rail, rail + r);
    sort(board, board + n);

    boardSum = 0;
    for (i = 0; i &lt; n; i ++)
        boardSum += board[i];
    //找到可以优化的R
    //用一个int表示前k个rail之和
    railSum = 0;
    for (i = 0; i &lt; r; i ++)
    {
        railSum += rail[i];
        if ( railSum &gt; boardSum )
        {
            railSum -= rail[i];
            break;
        }
    }

    -- i;
    for (; i &gt;= 0; i --)
    {
        curWaste = 0;
        maxWaste = boardSum - railSum;
        if ( Search(i) )
        {
            printf("%d\n", i+1);
            return;
        }
        railSum -= rail[i];
    }
    printf("0\n");
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/06/23/usaco-section-4-1-beef-mcnuggets/">USACO Section 4.1 Beef McNuggets</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-06-23T14:58:11+08:00" pubdate data-updated="true">Jun 23<span>rd</span>, 2011</time>
        
           | <a href="/blog/2011/06/23/usaco-section-4-1-beef-mcnuggets/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/06/23/usaco-section-4-1-beef-mcnuggets/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>题目大意：有n（&lt;=10）个整数a1, a2, …, an（&lt;=256），问是否存在无法用a1～an的线性表达式（k1a1 + k2a2 + … + knan）组成的数，如果有，其中最大的数是多少？（这个数的上限为2,000,000,000！）</p>

<p>思路：本想可以用简单的DP来实现，但一看到2,000,000,000的上限，放弃了DP的想法，结果好几天都没有思路。如果这个上限可以下降的足够小，那该多好！上网查了下资料以及问了下周围同学，得到一个结论：a1~an所无法组成的最大数的上限可以为其中最大两个数的最小公倍数！这样的话，题目的上限就可以一下子缩小到256×256了！DP就变得可行了。</p>

<p>其实，完整的证明我也暂时不能完全理解，这里先给出只有两个数的情况。</p>

<p>当有两个数a1和a2，a1和a2互质，可以证明无法用他们表达的数的上限为a1×a2，即大于a1×a2的数都可以表示成k1×a1+k2×a2。</p>

<p>即，对于任意正整数x，有：</p>

<pre><code>a1*a2 + x = k1*a1 + k2*a2

=&gt;  (a2 - k1)*a1 + x = k2*a1
</code></pre>

<p>因为k1任意，所以a2-k1也任意，将(a2-k1)<em>a1对a2取模，因为a1和a2互质，所以余数必然在0～a2-1的范围内，设为x’。另外，因为x也是任意的，所以我们将x表示成k</em>a2-x’。这样，等式左半边就可以被a2整数，等式得证。</p>

<p>再一次意识到，数学对于计算机科学来说是多么的重要！</p>

<p>好！上限确定下来之后，剩下的就是简单的DP了，以下是关键代码：</p>

<pre><code>void Solve ()
{
     int i, j, bound, gcdNum;

     gcdNum = box[0];
     for (i = 1; i &lt; n; i ++)
          gcdNum = gcd(gcdNum, box[i]);
     if ( gcdNum != 1 )
     {
          printf("0\n");
          return;
     }

     canMake[0] = 1;
     sort(box, box+n);
     bound = box[n-1] * box[n-1];
     for (i = 0; i &lt; bound; i ++)
     {
          if ( ! canMake[i] )
               continue;
          for (j = 0; j &lt; n; j ++)
          {
               if ( i + box[j] &lt; bound )
                    canMake[i+box[j]] = 1;
          }
     }

     for (i = bound-1; i &gt;= 0; i --)
     {
          if ( !canMake[i] )
          {
               printf("%d\n", i);
               return;
          }
     }
     printf("0\n");
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/05/31/usaco-section-3-4-raucous-rockers/">USACO Section 3.4 Raucous Rockers</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-05-31T10:52:29+08:00" pubdate data-updated="true">May 31<span>st</span>, 2011</time>
        
           | <a href="/blog/2011/05/31/usaco-section-3-4-raucous-rockers/#disqus_thread"
             data-disqus-identifier="http://quxiao.github.io/blog/2011/05/31/usaco-section-3-4-raucous-rockers/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>题目大意：有N(&lt;=20)首歌，打算放在M(&lt;=20)张CD中，每张CD可存储T(&lt;=20)分钟的音乐，给定每首歌的时长，问如何将歌曲按照日期（也就是输入）的顺序，存在这M张CD中，并且每首歌不可以分开存在多张CD上，使得存储的歌曲的数目最多。</p>

<p>来看给的样例：</p>

<pre><code>4 5 2
4 3 4 2
</code></pre>

<p>答案是3，可以直接看出，存放的方案是将第1首4分钟的歌存入第1张CD，然后将第2首3分钟和第4首2分钟的歌存入第2张CD。</p>

<p>思路：</p>

<pre><code>一看到题，就冲动的想到搜索。后来理智还是打败了冲动，20层的搜索还是有些接受不了。于是试着看这题能不能DP。DP的关键就是能否准确的记录子问题，我们来想一想子问题应该如何表示。很自然的，子问题可以表示为：前n首歌考虑放入前m张CD，所能放入的最大歌曲数。然后我们就可以将问题逐渐扩展，直至N、M的规模。但是，子问题如何扩展呢？那就是将[n][m]的情况下，考虑第n+1首歌。如果不放这首歌，就转化为[n+1][m]；如果放这首歌，可以分两种情况：将第n+1首歌放在第m张CD上，将第n+1首歌放在第m+1张CD上。那怎么判断第n+1首歌可以放入第m张CD上呢？因此，还需要一个维度，那就是在[n][m]的规模下，第m张CD还剩余的时长。最后，子问题就可以表示成如下的形式：
</code></pre>

<p><code>maxSong[songNum][diskNum][remain]</code></p>

<ul>
<li><p>songNum表示已考虑到的前songNum首歌</p></li>
<li><p>diskNum表示已考虑到的前diskNum张CD</p></li>
<li><p>remain表示在第diskNum张CD上剩余的时长</p></li>
</ul>


<p><code>maxSong[songNum][diskNum][remain]</code>（假设值为n）可以扩展为以下状态：</p>

<ol>
<li><p> <code>maxSong[songNum+1][diskNum][remain]</code>( = n ) 不放第songNum+1首歌</p></li>
<li><p> <code>maxSong[songNum+1][diskNum][remain-songTime[songNum+1]]</code>( = n+1 ) 将第songNum+1首歌放入第diskNum张CD</p></li>
<li><p> <code>maxSong[songNum+1][diskNum+1][T-songTime[songNum+1]]</code>( = n + 1 ) 将第songNum+1首歌放入第diskNum+1张CD</p></li>
</ol>


<p>这样，按n、m和t的规模从小到大一次进行扩展，最终maxSong中最大的值即为答案。</p>

<p>关键代码如下：</p>

<pre><code>void Expand(int songNum, int diskNum, int remain)
{
     if ( maxSong[songNum][diskNum][remain] == -1 )
           return;
     if ( songNum == N &amp;&amp; diskNum == M )
           return;
     int curMax = maxSong[songNum][diskNum][remain];
     if ( remain &gt;= songTime[songNum+1] )
     {
          maxSong[songNum+1][diskNum][remain-songTime[songNum+1]] =
                max( maxSong[songNum+1][diskNum][remain-songTime[songNum+1]], curMax+1);
     }
     if ( T &gt;= songTime[songNum+1] )
     {
           maxSong[songNum+1][diskNum+1][T-songTime[songNum+1]] =
                max( maxSong[songNum+1][diskNum+1][T-songTime[songNum+1]], curMax+1);
     }
     maxSong[songNum+1][diskNum][remain] = max( maxSong[songNum+1][diskNum][remain], curMax);
}

void Solve ()
{
     int i, j, k, ans;
     ans = -1;
     memset(maxSong, -1, sizeof(maxSong));
     maxSong[0][0][0] = 0;
     for (i = 0; i &lt;= M; i ++)
     {
           for (j = 0; j &lt;= N; j ++)
           {
                for (k = 0; k &lt;= T; k ++)
                {
                     Expand(j, i, k);
                }
           }
     }

     for (i = 0; i &lt;= M; i ++)
     {
           for (j = 0; j &lt;= N; j ++)
           {
                for (k = 0; k &lt;= T; k ++)
                {
                     if ( maxSong[j][i][k] &gt; ans )
                     {
                           ans = maxSong[j][i][k];
                     }
                }
           }
     }
     printf("%d\n", ans);
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/5/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/3/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/01/31/typelist-and-abstract-fatory/">Typelist && Abstract Fatory</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/01/23/typelist-in-template-metaprogramming/">模板元编程中的Typelist</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/01/01/from_2013_to_2014/">从2013到2014</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/11/30/information_retrievial_in_practice_note_architecture/">《Information Retrieval in Practice》笔记——整体架构</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/11/22/presentation-based-development/">“基于演示的开发”</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/quxiao">@quxiao</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'quxiao',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Xavier -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'qxavier';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
